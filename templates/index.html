<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Author: Niccolò Zamborlini (encom.io) -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Real-time observability dashboard for OpenClaw multi-agent systems, with drilldowns, causal graph and operational telemetry.">
    <meta name="keywords" content="OpenClaw, observability, swarm, agents, telemetry, dashboard, causal graph">
    <meta name="theme-color" content="#0b1020">
    <meta name="application-name" content="OpenClaw Swarm Observatory">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OpenClaw Observatory">
    <meta name="author" content="Niccolò Zamborlini">
    <meta name="organization" content="encom.io">
    <meta name="project-url" content="https://github.com/virgolamobile/openclaw-swarm-observatory/tree/main">
    <link rel="manifest" href="/static/manifest.webmanifest">
    <link rel="icon" type="image/svg+xml" href="/static/logo-oso-light.svg">
    <link rel="apple-touch-icon" href="/static/logo-oso-light.svg">
    <title>OpenClaw Swarm Observatory</title>
    <script src="/static/vendor/socket.io/socket.io.min.js"></script>
    <link rel="stylesheet" href="/static/vendor/highlightjs/github-dark.min.css">
    <script src="/static/vendor/marked/marked.min.js"></script>
    <script src="/static/vendor/dompurify/purify.min.js"></script>
    <script src="/static/vendor/highlightjs/highlight.min.js"></script>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #121a30;
            --panel-soft: #17233e;
            --text: #e8eefc;
            --muted: #a9b7d9;
            --good: #16c784;
            --warn: #f59e0b;
            --bad: #ef4444;
            --border: #2a3758;
        }
        * { box-sizing: border-box; }
        html, body {
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        img, svg {
            -webkit-user-drag: none;
            user-drag: none;
        }
        input, textarea, [contenteditable="true"], .docs-content pre, .docs-content code {
            -webkit-user-select: text;
            user-select: text;
        }
        body {
            margin: 0;
            font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: linear-gradient(180deg, #090f1f 0%, #0b1020 100%);
            color: var(--text);
        }
        header {
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(6px);
            background: rgba(11, 16, 32, 0.94);
            border-bottom: 1px solid var(--border);
            padding: 14px 18px;
        }
        .title-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }
        .title-line h1 { margin: 0; font-size: 1.15rem; }
        .brand-wrap {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .brand-logo {
            height: 34px;
            width: auto;
            flex: 0 0 auto;
        }
        .meta { color: var(--muted); font-size: .85rem; }
        .meta-actions { display: flex; align-items: center; gap: 8px; }
        .header-link {
            border: 1px solid var(--border);
            background: #111a31;
            color: #d8e4ff;
            border-radius: 8px;
            padding: 5px 10px;
            font-size: .78rem;
            cursor: pointer;
        }
        .header-link:hover { border-color: #4b6192; }
        #last-refresh {
            display: inline-flex;
            align-items: center;
            gap: 7px;
            border: 1px solid color-mix(in srgb, var(--good) 34%, var(--border));
            background: linear-gradient(
                180deg,
                color-mix(in srgb, var(--good) 12%, var(--panel-soft)),
                color-mix(in srgb, var(--good) 5%, var(--panel))
            );
            color: var(--text);
            border-radius: 999px;
            padding: 5px 11px;
            font-size: .74rem;
            letter-spacing: .3px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            text-transform: uppercase;
            box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--good) 12%, transparent);
        }
        #last-refresh::before {
            content: '';
            width: 7px;
            height: 7px;
            border-radius: 999px;
            background: var(--good);
            box-shadow: 0 0 0 0 color-mix(in srgb, var(--good) 32%, transparent);
        }
        #last-refresh[data-state="running"] {
            border-color: color-mix(in srgb, var(--warn) 46%, var(--border));
            background: linear-gradient(
                180deg,
                color-mix(in srgb, var(--warn) 15%, var(--panel-soft)),
                color-mix(in srgb, var(--warn) 6%, var(--panel))
            );
            box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--warn) 16%, transparent);
        }
        #last-refresh[data-state="running"]::before {
            background: var(--warn);
            animation: refresh-pulse 1.05s ease-in-out infinite;
        }
        @keyframes refresh-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 color-mix(in srgb, var(--warn) 34%, transparent); }
            70% { transform: scale(1.22); box-shadow: 0 0 0 7px color-mix(in srgb, var(--warn) 0%, transparent); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 color-mix(in srgb, var(--warn) 0%, transparent); }
        }
        .overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
            margin-top: 12px;
        }
        .kpi {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 9px;
            cursor: pointer;
            transition: border-color .14s ease, transform .14s ease, box-shadow .14s ease;
        }
        .kpi:hover {
            border-color: #5b8cff;
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(8, 15, 30, .28);
        }
        .kpi:focus-visible {
            outline: 2px solid #5b8cff;
            outline-offset: 2px;
        }
        .kpi .label {
            color: var(--muted);
            font-size: .76rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .kpi .value { font-size: 1.2rem; font-weight: 700; margin-top: 4px; }

        .layout {
            display: grid;
            grid-template-columns: minmax(0, 1.7fr) minmax(360px, 1fr);
            gap: 14px;
            padding: 14px;
            align-items: start;
        }
        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 12px;
        }
        .panel h2 { margin: 0 0 10px; font-size: .97rem; }
        .title-with-help { display: flex; align-items: center; gap: 6px; }
        .help-btn {
            border: 1px solid var(--border);
            background: #111a31;
            color: var(--muted);
            border-radius: 999px;
            width: 18px;
            height: 18px;
            line-height: 16px;
            text-align: center;
            padding: 0;
            font-size: .72rem;
            cursor: pointer;
        }
        .help-btn:hover { color: #fff; border-color: #5b8cff; }
        .help-btn.micro {
            width: 16px;
            height: 16px;
            line-height: 14px;
            font-size: .65rem;
        }
        .panel h3 {
            margin: 0 0 8px;
            font-size: .82rem;
            text-transform: uppercase;
            letter-spacing: .4px;
            color: var(--muted);
        }

        #agent-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 10px;
        }
        .agent-card {
            background: var(--panel-soft);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px;
            position: relative;
            display: grid;
            grid-template-columns: minmax(0, 1fr) 94px;
            column-gap: 10px;
            align-items: start;
            cursor: pointer;
            transition: transform .12s ease, border-color .12s ease;
        }
        .agent-main {
            min-width: 0;
        }
        .agent-side {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 6px;
            min-width: 0;
        }
        .agent-side .chip.live {
            align-self: flex-end;
        }
        .agent-card:hover { transform: translateY(-1px); border-color: #4b6192; }
        .agent-card:focus-visible {
            outline: 2px solid #5b8cff;
            outline-offset: 2px;
            border-color: #5b8cff;
        }
        .agent-click-hint {
            margin-top: 8px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            border: 1px dashed rgba(143, 179, 255, .44);
            border-radius: 999px;
            padding: 2px 7px;
            font-size: .67rem;
            color: #b9ccf5;
            background: rgba(18, 31, 59, .44);
            letter-spacing: .18px;
        }
        .agent-card:hover .agent-click-hint {
            color: #e7efff;
            border-color: rgba(143, 179, 255, .72);
            background: rgba(22, 38, 72, .62);
        }
        .agent-card.selected {
            border-color: #8fb3ff;
            background: linear-gradient(180deg, rgba(34, 55, 102, .55), rgba(23, 36, 67, .72));
            transform: translateY(-1px);
            box-shadow:
                inset 0 0 0 1px rgba(143,179,255,.62),
                0 0 0 2px rgba(143,179,255,.22),
                0 10px 22px rgba(5, 12, 28, .46);
        }
        .agent-card.selected::before {
            content: '';
            position: absolute;
            left: -1px;
            top: 8px;
            bottom: 8px;
            width: 4px;
            border-radius: 999px;
            background: #8fb3ff;
            box-shadow: 0 0 12px rgba(143,179,255,.65);
        }
        .agent-card.loading {
            border-color: #7aa3ff;
            box-shadow: inset 0 0 0 1px rgba(122,163,255,.48), 0 0 0 2px rgba(122,163,255,.12);
        }
        .agent-card.loading .agent-badge::before {
            animation: selected-loading-pulse .9s ease-in-out infinite;
        }
        @keyframes selected-loading-pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.35); opacity: .75; }
            100% { transform: scale(1); opacity: 1; }
        }
        .agent-top { display:flex; justify-content:space-between; align-items:center; }
        .chip {
            border: 1px solid var(--border);
            border-radius: 999px;
            font-size: .72rem;
            padding: 2px 7px;
            color: var(--muted);
        }
        .chip.live { color: var(--good); border-color: rgba(22,199,132,.4); }
        .chip.warn { color: var(--warn); border-color: rgba(245,158,11,.45); }
        .chip.bad { color: var(--bad); border-color: rgba(239,68,68,.45); }
        .chip.live-indicator {
            border-radius: 6px;
            padding: 2px 6px;
            font-size: .62rem;
            font-weight: 700;
            letter-spacing: .45px;
            text-transform: uppercase;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            background: rgba(10, 18, 34, .86);
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.04);
        }
        .chip.live-indicator.live {
            color: #9af2c8;
            border-color: rgba(22,199,132,.55);
            background: linear-gradient(180deg, rgba(12,40,31,.82), rgba(10,22,20,.92));
        }
        .chip.live-indicator.warn {
            color: #f8d28a;
            border-color: rgba(245,158,11,.55);
            background: linear-gradient(180deg, rgba(56,38,13,.82), rgba(30,22,11,.92));
        }
        .chip.live-indicator.bad {
            color: #ffb3b3;
            border-color: rgba(239,68,68,.58);
            background: linear-gradient(180deg, rgba(62,17,17,.82), rgba(30,12,12,.92));
        }
        .kv { margin: 5px 0; font-size: .82rem; color: #c7d4f6; }
        .muted { color: var(--muted); }
        .agent-badge {
            --agent-accent: #6ea8ff;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid color-mix(in srgb, var(--agent-accent) 52%, transparent);
            background: color-mix(in srgb, var(--agent-accent) 16%, #101a32);
            color: #eaf1ff;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: .74rem;
            line-height: 1;
            font-weight: 600;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            letter-spacing: .2px;
            white-space: nowrap;
            vertical-align: middle;
        }
        .agent-badge::before {
            content: '';
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: var(--agent-accent);
            box-shadow: 0 0 8px color-mix(in srgb, var(--agent-accent) 60%, transparent);
        }
        .agent-badge.compact {
            font-size: .69rem;
            padding: 2px 7px;
            gap: 5px;
        }
        .agent-badge.nav-action {
            cursor: pointer;
        }
        .agent-badge.nav-action:hover {
            filter: brightness(1.08);
        }
        .agent-badge.nav-action:focus-visible {
            outline: 2px solid #5b8cff;
            outline-offset: 2px;
        }

        .selection-hint {
            border: 1px dashed #3a4a73;
            border-radius: 8px;
            color: #c6d3f4;
            padding: 9px;
            margin-bottom: 10px;
            font-size: .84rem;
            background: rgba(21,31,56,.5);
        }
        .selection-hint.hidden {
            display: none;
        }

        .panel-head {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 8px;
        }
        .panel-head h2 {
            margin-right: 8px;
        }
        .telemetry-warning-btn {
            border: 0;
            background: transparent;
            color: #f8d28a;
            width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin-bottom: 4px;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            flex: 0 0 auto;
        }
        .telemetry-warning-btn.bad {
            color: #ffb3b3;
        }
        .telemetry-warning-btn.hidden {
            display: none;
        }
        .telemetry-warning-btn:hover {
            filter: brightness(1.08);
        }
        .telemetry-warning-btn:focus-visible {
            outline: 2px solid #5b8cff;
            outline-offset: 2px;
            border-radius: 4px;
        }

        .telemetry-modal {
            position: fixed;
            inset: 0;
            background: rgba(5,8,16,.72);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 40;
            padding: 18px;
        }
        .telemetry-modal.open { display: flex; }
        .telemetry-card {
            width: min(760px, 96vw);
            max-height: 86vh;
            overflow: auto;
            background: #101a31;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
        }
        .telemetry-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .telemetry-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }
        .telemetry-block {
            border: 1px solid rgba(255,255,255,.08);
            border-radius: 8px;
            padding: 8px;
            background: rgba(12,20,38,.72);
        }
        .telemetry-block h4 {
            margin: 0 0 6px;
            font-size: .78rem;
            color: #cfe0ff;
            text-transform: uppercase;
            letter-spacing: .35px;
        }

        .telemetry-check {
            margin: -4px 0 10px;
            font-size: .73rem;
            color: #a9b7d9;
        }
        .telemetry-check.warn {
            color: #f7c56a;
        }
        .telemetry-check.bad {
            color: #ff9797;
        }

        .token-mini-widget {
            width: 100%;
            border: 1px solid rgba(255,255,255,.12);
            border-radius: 8px;
            padding: 5px;
            background: rgba(12, 22, 41, .88);
            margin-top: 12px;
        }
        .token-mini-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        .token-mini-label {
            color: #a9b7d9;
            font-size: .66rem;
            letter-spacing: .2px;
            text-transform: uppercase;
        }
        .token-mini-canvas {
            width: 100%;
            height: 64px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,.08);
            background: linear-gradient(180deg, rgba(18,30,56,.6), rgba(12,22,41,.86));
        }
        .token-mini-value {
            color: #d7e5ff;
            font-size: .7rem;
            text-align: right;
        }
        @media (max-width: 980px) {
            .agent-card {
                grid-template-columns: minmax(0, 1fr) 88px;
            }
        }

        .list {
            max-height: 260px;
            overflow: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #0f1830;
        }
        .row {
            padding: 8px 9px;
            border-bottom: 1px solid rgba(255,255,255,.06);
            font-size: .81rem;
        }
        .row:last-child { border-bottom: none; }
        .when { color: var(--muted); font-size: .74rem; }

        .investigation { position: sticky; top: 96px; }

        .mobile-resolution-warning {
            display: none;
            margin: 10px 14px 0;
            border: 1px solid rgba(245, 158, 11, .5);
            background: rgba(245, 158, 11, .12);
            color: #f8d28a;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: .78rem;
            line-height: 1.35;
        }
        .tabs { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; }
        .tab {
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 4px 9px;
            color: var(--muted);
            background: #111a31;
            cursor: pointer;
            font-size: .75rem;
        }
        .tab.active { color: #fff; border-color: #5b8cff; background: #1a2d56; }
        .tab-context-help {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin: 0 0 10px;
            padding: 6px 8px;
            border-left: 2px solid rgba(91, 140, 255, .45);
            background: rgba(15, 27, 50, .38);
            border-radius: 6px;
        }
        .tab-context-text {
            color: #a9b7d9;
            font-size: .74rem;
            line-height: 1.3;
        }
        .tab-context-help .help-btn {
            border-style: dashed;
            background: transparent;
            width: 17px;
            height: 17px;
            line-height: 15px;
            font-size: .66rem;
            color: #9cb2e5;
            flex: 0 0 auto;
        }

        .trace {
            max-height: 68vh;
            overflow: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #0f1830;
            padding: 8px;
        }
        .trace-item {
            border: 1px solid rgba(255,255,255,.08);
            border-radius: 8px;
            background: #111a31;
            padding: 8px;
            margin-bottom: 8px;
            font-size: .81rem;
        }
        .trace-item.linked {
            border-color: #5b8cff;
            box-shadow: inset 0 0 0 1px rgba(91,140,255,.32);
            background: #16284d;
        }
        .trace-item.jump-target {
            animation: jumpTargetPulse 1.6s ease-in-out 2;
            border-color: #8db0ff;
            box-shadow: 0 0 0 1px rgba(141,176,255,.45), 0 0 14px rgba(91,140,255,.35);
        }
        @keyframes jumpTargetPulse {
            0%, 100% { background: #16284d; }
            50% { background: #213c71; }
        }
        .backlink-banner {
            border: 1px solid rgba(91,140,255,.45);
            border-radius: 8px;
            background: rgba(91,140,255,.12);
            padding: 8px;
            margin-bottom: 8px;
            font-size: .79rem;
            color: #d9e6ff;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
        }

        .graph-wrap {
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #0f1830;
            padding: 8px;
            overflow: auto;
            max-height: 68vh;
        }
        .graph-stage {
            min-height: 420px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,.08);
            border-radius: 8px;
            background: #0d172d;
            cursor: grab;
        }
        .graph-stage.dragging { cursor: grabbing; }
        .graph-node-text { font-size: 11px; fill: #e8eefc; }
        .graph-edge-text { font-size: 10px; fill: #a9b7d9; }
        .graph-summary {
            border: 1px solid rgba(255,255,255,.1);
            border-radius: 8px;
            background: rgba(15, 25, 48, .72);
            padding: 8px;
            margin-bottom: 8px;
        }
        .graph-legend {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 6px;
        }
        .graph-legend-item {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: .7rem;
            color: #bdd0f8;
            border: 1px solid rgba(255,255,255,.12);
            border-radius: 999px;
            padding: 1px 7px;
        }
        .graph-legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            flex: 0 0 auto;
        }
        .graph-node-rect {
            transition: filter .45s ease, stroke-width .45s ease, opacity .45s ease, stroke .45s ease;
        }
        .graph-node.live .graph-node-rect {
            animation: graphPulseNode 1.15s ease-in-out infinite;
        }
        .graph-node.weight-up .graph-node-rect {
            animation: graphWeightUp 1.1s ease;
        }
        .graph-node.weight-down .graph-node-rect {
            animation: graphWeightDown 1.1s ease;
        }
        .graph-node.trigger-source .graph-node-rect {
            animation: graphTriggerGlow 0.9s ease-in-out infinite, graphImpactBorder 1.1s linear infinite;
            stroke: #ffe08a;
        }
        .graph-node.impact .graph-node-rect {
            animation: graphImpactBorder 1.25s linear infinite;
        }
        .graph-node.selected .graph-node-rect {
            filter: drop-shadow(0 0 7px rgba(91,140,255,.65));
            stroke-width: 2.1;
        }
        .graph-edge-line {
            transition: stroke-width .45s ease, opacity .45s ease, stroke .45s ease;
            opacity: .72;
        }
        .graph-edge.live .graph-edge-line {
            animation: graphPulseEdge 0.95s ease-in-out infinite, graphDataFlow 1.15s linear infinite;
            stroke-dasharray: 8 6;
        }
        .graph-edge.trigger-flow .graph-edge-line {
            animation: graphPulseEdge 0.7s ease-in-out infinite, graphDataFlow 0.58s linear infinite;
            stroke: #b9d2ff;
            stroke-dasharray: 11 6;
            opacity: 1;
        }
        .graph-edge.selected .graph-edge-line {
            stroke: #8db0ff;
            stroke-width: 2;
            opacity: .95;
        }
        @keyframes graphPulseNode {
            0%, 100% { filter: drop-shadow(0 0 0 rgba(22,199,132,.0)); }
            50% { filter: drop-shadow(0 0 14px rgba(22,199,132,.68)); }
        }
        @keyframes graphWeightUp {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.28); }
            100% { filter: brightness(1); }
        }
        @keyframes graphWeightDown {
            0% { opacity: 1; }
            50% { opacity: .74; }
            100% { opacity: 1; }
        }
        @keyframes graphTriggerGlow {
            0%, 100% { filter: drop-shadow(0 0 0 rgba(255,208,96,.0)); }
            50% { filter: drop-shadow(0 0 16px rgba(255,208,96,.85)); }
        }
        @keyframes graphPulseEdge {
            0%, 100% { opacity: .72; }
            50% { opacity: 1; }
        }
        @keyframes graphDataFlow {
            from { stroke-dashoffset: 0; }
            to { stroke-dashoffset: -56; }
        }
        @keyframes graphImpactBorder {
            0% {
                stroke-width: 2;
                filter: drop-shadow(0 0 0 rgba(255,208,96,0));
            }
            50% {
                stroke-width: 3.2;
                filter: drop-shadow(0 0 11px rgba(255,208,96,.72));
            }
            100% {
                stroke-width: 2;
                filter: drop-shadow(0 0 0 rgba(255,208,96,0));
            }
        }
        .graph-actions {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 6px;
        }
        .graph-expand-btn {
            border: 1px solid rgba(255,255,255,.18);
            border-radius: 8px;
            background: #12203d;
            color: #d7e6ff;
            font-size: .73rem;
            line-height: 1;
            padding: 5px 8px;
            cursor: pointer;
        }
        .graph-expand-btn:hover {
            border-color: #5b8cff;
            background: #1a2d56;
        }

        .graph-fullscreen-modal {
            position: fixed;
            inset: 0;
            background: rgba(5, 10, 20, .82);
            z-index: 29;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 12px;
        }
        .graph-fullscreen-modal.open { display: flex; }
        .graph-fullscreen-card {
            width: min(1400px, 98vw);
            height: min(92vh, 980px);
            background: #0f1830;
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            display: grid;
            grid-template-rows: auto 1fr;
        }
        .graph-fullscreen-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            background: #101a32;
        }
        .graph-fullscreen-body {
            padding: 10px;
            overflow: auto;
        }
        .graph-fullscreen-body .graph-wrap {
            max-height: none;
            height: 100%;
        }
        .graph-fullscreen-body .graph-stage {
            min-height: max(72vh, 520px);
        }

        .pill {
            display: inline-block;
            border: 1px solid rgba(255,255,255,.18);
            border-radius: 999px;
            padding: 1px 7px;
            margin-right: 6px;
            font-size: .71rem;
            color: var(--muted);
        }
        .status-ok { color: var(--good); }
        .status-bad { color: var(--bad); }
        .status-warn { color: var(--warn); }
        .small { font-size: .75rem; }
        .trace-expand {
            border: 1px solid rgba(255,255,255,.1);
            border-radius: 8px;
            background: rgba(12, 20, 38, .55);
            margin-top: 6px;
            padding: 6px 8px;
        }
        .trace-expand summary {
            cursor: pointer;
            color: #dce7ff;
            font-size: .76rem;
            line-height: 1.35;
        }
        .trace-expand summary::marker {
            color: #9fb8f6;
        }
        .trace-expand[open] summary {
            margin-bottom: 6px;
        }
        .trace-list {
            margin: 0;
            padding-left: 18px;
            color: #c9d7f8;
            font-size: .74rem;
            line-height: 1.35;
        }
        .trace-list li {
            margin: 2px 0;
            word-break: break-word;
        }
        .reasoning-compact {
            background: rgba(14, 24, 45, .58);
            border-radius: 8px;
            padding: 5px 7px;
            margin-top: 7px;
        }
        .reasoning-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
            font-size: .72rem;
            line-height: 1.25;
            color: #d9e5ff;
        }
        .reasoning-table th,
        .reasoning-table td {
            text-align: left;
            vertical-align: top;
            padding: 1px 0;
            border: 0;
        }
        .reasoning-table th {
            width: 72px;
            padding-right: 8px;
            color: #9db2df;
            text-transform: uppercase;
            letter-spacing: .35px;
            font-size: .65rem;
            font-weight: 500;
        }
        .reasoning-table td {
            overflow-wrap: anywhere;
        }
        .reason-tag {
            display: inline-flex;
            align-items: center;
            border: 1px solid rgba(91,140,255,.45);
            background: rgba(91,140,255,.16);
            color: #dce8ff;
            border-radius: 999px;
            font-size: .68rem;
            padding: 1px 7px;
            margin-left: 6px;
            vertical-align: middle;
        }
        .reasoning-details {
            margin-top: 4px;
        }
        .reasoning-details summary {
            cursor: pointer;
            color: #cfe0ff;
            font-size: .69rem;
            line-height: 1.25;
        }
        .reasoning-details summary::marker {
            color: #9fb8f6;
        }
        .reasoning-details-row {
            margin-top: 4px;
            display: grid;
            grid-template-columns: 72px 1fr;
            gap: 8px;
            align-items: start;
        }
        .reasoning-details-label {
            color: #9db2df;
            text-transform: uppercase;
            letter-spacing: .35px;
            font-size: .65rem;
        }
        .reasoning-compact-list {
            margin: 3px 0 0;
            padding-left: 14px;
            font-size: .7rem;
            color: #cbdaf8;
            line-height: 1.25;
        }
        .reasoning-compact-list li {
            margin: 1px 0;
        }
        .decision-order-hint {
            margin-bottom: 6px;
            color: #a9b7d9;
            font-size: .72rem;
        }
        .decision-timeline-head {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 6px;
        }
        .decision-meta-left {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
            min-width: 0;
        }
        .decision-time-box {
            text-align: right;
            flex: 0 0 auto;
        }
        .decision-time-strong {
            font-size: .82rem;
            color: #ecf3ff;
            font-weight: 600;
            line-height: 1.2;
            letter-spacing: .1px;
        }
        .decision-pills {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
        }
        .trace-item.decision-item {
            border-color: rgba(122,163,255,.28);
            background: linear-gradient(180deg, rgba(20,33,61,.9), rgba(16,27,50,.9));
            box-shadow: inset 0 0 0 1px rgba(122,163,255,.08);
        }
        .trace-item.decision-item.alt {
            background: linear-gradient(180deg, rgba(18,30,55,.9), rgba(14,24,46,.9));
        }
        .trace-item.decision-item .decision-line {
            margin-top: 4px;
            border-left: 2px solid rgba(91,140,255,.35);
            padding-left: 8px;
        }
        .decision-logic {
            margin-top: 6px;
            padding-top: 2px;
        }
        .decision-logic-toggle {
            list-style: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 999px;
            border: 1px solid rgba(91,140,255,.42);
            background: rgba(91,140,255,.12);
            color: #dce8ff;
            user-select: none;
        }
        .decision-logic-toggle::marker,
        .decision-logic-toggle::-webkit-details-marker {
            display: none;
            content: '';
        }
        .logic-toggle-icon {
            width: 7px;
            height: 7px;
            border-right: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            transform: rotate(-45deg);
            transition: transform .14s ease;
            margin-right: 1px;
        }
        .decision-logic[open] .logic-toggle-icon {
            transform: rotate(45deg);
            margin-top: -1px;
        }
        .decision-logic-body {
            margin-top: 6px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,.11);
            background: rgba(12,20,38,.54);
            padding: 6px 7px;
        }
        .investigation-breadcrumb {
            border: 1px dashed rgba(255,255,255,.2);
            border-radius: 8px;
            background: rgba(16, 26, 50, .48);
            color: #cfdcff;
            padding: 6px 8px;
            margin: 7px 0 10px;
            font-size: .74rem;
            line-height: 1.4;
        }
        .investigation-breadcrumb .sep {
            color: #8aa2da;
            margin: 0 5px;
        }
        .investigation-breadcrumb .crumb-strong {
            color: #ecf3ff;
            font-weight: 600;
        }
        .crumb-btn {
            border: 1px solid rgba(255,255,255,.18);
            background: rgba(17, 26, 49, .72);
            color: #dbe8ff;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: .72rem;
            cursor: pointer;
        }
        .crumb-btn:hover {
            border-color: #5b8cff;
            color: #fff;
        }
        .crumb-btn.active {
            border-color: #5b8cff;
            background: #1a2d56;
            color: #fff;
        }

        .docs-modal {
            position: fixed;
            inset: 0;
            background: rgba(5, 10, 20, .76);
            z-index: 25;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }
        .docs-modal.open { display: flex; }
        .docs-card {
            width: min(1100px, 96vw);
            height: min(78vh, 820px);
            background: #0f1830;
            border: 1px solid var(--border);
            border-radius: 12px;
            display: grid;
            grid-template-columns: 280px 1fr;
            overflow: hidden;
        }
        .docs-menu {
            border-right: 1px solid var(--border);
            background: #101a32;
            overflow: auto;
            padding: 10px;
        }
        .docs-menu-empty {
            color: var(--muted);
            font-size: .79rem;
            padding: 8px;
            border: 1px dashed rgba(255,255,255,.18);
            border-radius: 8px;
        }
        .docs-tree-group {
            margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,.08);
            border-radius: 8px;
            background: rgba(18, 31, 60, .55);
            overflow: hidden;
        }
        .docs-menu-btn {
            width: 100%;
            text-align: left;
            border: 1px solid rgba(255,255,255,.08);
            background: #13203c;
            color: #d9e5ff;
            border-radius: 8px;
            padding: 7px 8px;
            margin-bottom: 7px;
            font-size: .79rem;
            cursor: pointer;
        }
        .docs-menu-btn.main {
            margin: 0;
            border: 0;
            border-bottom: 1px solid rgba(255,255,255,.08);
            border-radius: 0;
            background: #13203c;
            font-weight: 600;
            font-size: .8rem;
        }
        .docs-menu-btn.sub {
            margin: 0;
            border: 0;
            border-radius: 0;
            background: transparent;
            color: #c7d7ff;
            padding: 6px 8px 6px 20px;
            font-size: .76rem;
        }
        .docs-subtree {
            display: grid;
            gap: 0;
            padding: 2px 0;
            background: rgba(14, 23, 42, .5);
        }
        .docs-menu-btn.active { border-color: #5b8cff; background: #1a2d56; }
        .docs-view {
            display: grid;
            grid-template-rows: auto 1fr;
            min-height: 0;
        }
        .docs-topbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
        }
        .docs-content {
            padding: 12px;
            overflow: auto;
            font-size: .84rem;
            line-height: 1.58;
            color: #dbe7ff;
        }
        .docs-content h1,
        .docs-content h2,
        .docs-content h3 {
            color: #e8efff;
            margin: 1.1em 0 .45em;
            line-height: 1.3;
        }
        .docs-content h1 { font-size: 1.24rem; border-bottom: 1px solid rgba(255,255,255,.12); padding-bottom: .24em; }
        .docs-content h2 { font-size: 1.05rem; }
        .docs-content h3 { font-size: .95rem; }
        .docs-content p,
        .docs-content li {
            color: #dbe7ff;
        }
        .docs-content a {
            color: #8db0ff;
        }
        .docs-content blockquote {
            margin: .8em 0;
            padding: .45em .8em;
            border-left: 3px solid #5b8cff;
            background: rgba(91,140,255,.08);
            color: #d2e2ff;
        }
        .docs-content code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            font-size: .78rem;
            background: rgba(255,255,255,.08);
            border-radius: 5px;
            padding: .08em .35em;
        }
        .docs-content pre {
            margin: .8em 0;
            border: 1px solid rgba(255,255,255,.13);
            border-radius: 8px;
            overflow: auto;
            background: #0b1327;
        }
        .docs-content pre code {
            display: block;
            background: transparent;
            padding: 12px;
            font-size: .76rem;
            line-height: 1.45;
            border-radius: 0;
        }
        .docs-anchor-target {
            scroll-margin-top: 14px;
        }

        .overview-modal {
            position: fixed;
            inset: 0;
            background: rgba(5, 10, 20, .76);
            z-index: 24;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }
        .overview-modal.open { display: flex; }
        .overview-card {
            width: min(980px, 96vw);
            height: min(76vh, 760px);
            background: #0f1830;
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            display: grid;
            grid-template-rows: auto 1fr;
        }
        .overview-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            background: #101a32;
        }
        .overview-body {
            padding: 12px;
            overflow: auto;
        }
        .overview-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 10px;
        }
        .overview-grid.deep {
            grid-template-columns: 280px 1fr;
            align-items: start;
        }
        .overview-detail {
            border: 1px solid rgba(255,255,255,.1);
            border-radius: 8px;
            background: #111a31;
            padding: 9px;
            font-size: .8rem;
        }
        .overview-agent-list {
            display: grid;
            gap: 7px;
            max-height: 56vh;
            overflow: auto;
        }
        .overview-agent-btn {
            width: 100%;
            text-align: left;
            border: 1px solid rgba(255,255,255,.12);
            background: #13203c;
            color: #d8e4ff;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            font-size: .78rem;
        }
        .overview-agent-btn.active {
            border-color: #5b8cff;
            background: #1a2d56;
        }
        .overview-subline {
            color: #aac0f3;
            font-size: .72rem;
            margin-top: 4px;
        }
        .overview-deep-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .overview-cta {
            border: 1px solid #4b6192;
            background: #13203c;
            color: #d8e4ff;
            border-radius: 7px;
            padding: 5px 9px;
            font-size: .74rem;
            cursor: pointer;
        }
        .overview-cta:hover { border-color: #5b8cff; }
        .overview-decision-list {
            display: grid;
            gap: 6px;
            margin: 0;
            padding: 0;
            list-style: none;
        }
        .overview-decision-item {
            border: 1px solid rgba(255,255,255,.1);
            border-radius: 8px;
            background: rgba(14, 23, 44, .56);
            padding: 7px;
        }
        .overview-decision-meta {
            color: #b3c6f4;
            font-size: .72rem;
            margin-bottom: 4px;
        }
        .overview-decision-text {
            color: #e2ecff;
            font-size: .78rem;
            line-height: 1.45;
            margin-bottom: 6px;
        }
        .overview-detail h4 {
            margin: 0 0 7px;
            font-size: .8rem;
            color: #d8e4ff;
            text-transform: uppercase;
            letter-spacing: .35px;
        }
        .overview-lines {
            margin: 0;
            padding-left: 16px;
            line-height: 1.5;
            color: #d4e2ff;
        }
        .overview-lines li { margin-bottom: 5px; }

        .content-updated {
            animation: contentFadeIn .24s ease-out;
            will-change: opacity, filter;
        }

        @keyframes contentFadeIn {
            from {
                opacity: .96;
                filter: brightness(1.03);
            }
            to {
                opacity: 1;
                filter: brightness(1);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .content-updated {
                animation: none;
            }
        }

        @media (max-width: 767px) {
            .layout { grid-template-columns: 1fr; }
            .investigation { position: static; }
            .trace { max-height: 52vh; }
            .overview-grid { grid-template-columns: 1fr; }
            .mobile-resolution-warning { display: block; }
        }

        @media (min-width: 768px) {
            .layout {
                grid-template-columns: minmax(0, 1.7fr) minmax(340px, 0.95fr);
            }
        }

        .site-footer {
            border-top: 1px solid var(--border);
            background: rgba(11, 16, 32, 0.92);
            padding: 12px 16px 14px;
        }
        .site-footer-inner {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
            color: var(--muted);
            font-size: .76rem;
            line-height: 1.5;
        }
        .site-footer-copyright {
            color: #d4e2ff;
            letter-spacing: .15px;
        }
        .site-footer-link {
            color: #c9d9ff;
            text-decoration: none;
            border-bottom: 1px dotted rgba(201, 217, 255, .45);
        }
        .site-footer-link:hover {
            color: #ffffff;
            border-bottom-color: rgba(255, 255, 255, .78);
        }
        .site-footer-app {
            display: inline-flex;
            align-items: center;
            justify-content: flex-end;
        }
        .footer-logo {
            height: 18px;
            width: auto;
            opacity: .96;
            flex: 0 0 auto;
        }
    </style>
</head>
<body>
    <header>
        <div class="title-line">
            <h1 class="title-with-help"><span class="brand-wrap">
                <img class="brand-logo" src="/static/logo-oso-light.svg" alt="OpenClaw Swarm Observatory">
            </span>
            </h1>
            <div class="meta-actions">
                <button class="header-link" id="open-docs-index" title="Open documentation index">Docs index</button>
                <div class="meta" id="last-refresh">refresh: --</div>
            </div>
        </div>
        <div class="overview">
            <openclaw-kpi-card class="kpi" data-overview="agents" data-kpi-key="agents" data-label="Observed agents" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-header-and-kpi-strip"></openclaw-kpi-card>
            <openclaw-kpi-card class="kpi" data-overview="cron" data-kpi-key="cron" data-label="Active cron jobs" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-cron-timeline-tab"></openclaw-kpi-card>
            <openclaw-kpi-card class="kpi" data-overview="user_agent" data-kpi-key="ua" data-label="User→agent interactions" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-user-to-agent-stream"></openclaw-kpi-card>
            <openclaw-kpi-card class="kpi" data-overview="agent_agent" data-kpi-key="aa" data-label="Agent→agent interactions" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-agent-to-agent-stream"></openclaw-kpi-card>
            <openclaw-kpi-card class="kpi" data-overview="interrupted" data-kpi-key="bad" data-label="Non-ok/interrupted tasks" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-strategic-usage-patterns"></openclaw-kpi-card>
        </div>
    </header>

    <div class="mobile-resolution-warning" role="status" aria-live="polite">
        Recommended minimum width: 768px for full observability layout.
    </div>

    <main class="layout">
        <section>
            <article class="panel">
                <div class="panel-head">
                    <h2 class="title-with-help">Swarm Overview
                        <button class="help-btn" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-swarm-overview-section" title="Open section guide">?</button>
                    </h2>
                    <button id="telemetry-warning-btn" class="telemetry-warning-btn hidden" title="Open telemetry warning details" aria-label="Open telemetry warning details">⚠️</button>
                </div>
                <div id="selection-hint" class="selection-hint">1) Select an agent to unlock deep investigation and causal graph analysis.</div>
                <div id="agent-grid"></div>
            </article>
            <article class="panel">
                <h2 class="title-with-help">Global streams
                    <button class="help-btn" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-global-streams-section" title="Open section guide">?</button>
                </h2>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                    <div>
                        <h3 class="title-with-help">User ↔ Agent
                            <button class="help-btn micro" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-user-to-agent-stream" title="Open stream guide">?</button>
                        </h3>
                        <openclaw-stream-list id="user-agent-list" class="list" data-mode="ua"></openclaw-stream-list>
                    </div>
                    <div>
                        <h3 class="title-with-help">Agent ↔ Agent
                            <button class="help-btn micro" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-agent-to-agent-stream" title="Open stream guide">?</button>
                        </h3>
                        <openclaw-stream-list id="agent-agent-list" class="list" data-mode="aa"></openclaw-stream-list>
                    </div>
                </div>
            </article>
        </section>

        <section class="investigation panel">
            <h2 id="drill-title" class="title-with-help">Deep investigation (select an agent)
                <button class="help-btn" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-investigation-console-section" title="Open section guide">?</button>
            </h2>
            <div class="small muted" id="selected-agent-label">Current agent: none</div>
            <div id="investigation-breadcrumb" class="investigation-breadcrumb">Path: Swarm</div>
            <div class="tabs">
                <button class="tab active" data-tab="decisions">Why decisions</button>
                <button class="tab" data-tab="soul">SOUL/file derivation</button>
                <button class="tab" data-tab="graph">Causal Graph</button>
                <button class="tab" data-tab="cron_timeline">Cron timeline</button>
                <button class="tab" data-tab="timeline">Full timeline</button>
                <button class="tab" data-tab="overview">Overview</button>
            </div>
            <div class="tab-context-help">
                <div class="tab-context-text" id="active-tab-help-text">Active tab guide: Why decisions.</div>
                <button class="help-btn micro" id="active-tab-help" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-why-decisions-tab" title="Open active tab guide">?</button>
            </div>
            <div id="drill-body" class="trace">Click an agent to open decision core analysis.</div>
        </section>
    </main>

    <footer class="site-footer" role="contentinfo" aria-label="Copyright and credits">
        <div class="site-footer-inner">
            <div class="site-footer-copyright">© <span id="footer-year"></span> Niccolò Zamborlini · encom.io · <a class="site-footer-link" href="https://github.com/virgolamobile" target="_blank" rel="noopener noreferrer">github.com/virgolamobile</a></div>
            <div class="site-footer-app"><img class="footer-logo" src="/static/logo-oso-light.svg" alt="OpenClaw Swarm Observatory"></div>
        </div>
    </footer>

    <div id="docs-modal" class="docs-modal" aria-hidden="true">
        <div class="docs-card" role="dialog" aria-modal="true" aria-label="Documentation">
            <aside id="docs-menu" class="docs-menu"></aside>
            <section class="docs-view">
                <div class="docs-topbar">
                    <strong id="docs-title">Documentation</strong>
                    <button class="header-link" id="close-docs">Close</button>
                </div>
                <div id="docs-content" class="docs-content">Loading documentation…</div>
            </section>
        </div>
    </div>

    <div id="overview-modal" class="overview-modal" aria-hidden="true">
        <div class="overview-card" role="dialog" aria-modal="true" aria-label="Overview Deep Detail">
            <div class="overview-head">
                <strong id="overview-title">Overview detail</strong>
                <button class="header-link" id="close-overview">Close</button>
            </div>
            <div class="overview-body" id="overview-content">Loading details…</div>
        </div>
    </div>

    <div id="graph-fullscreen-modal" class="graph-fullscreen-modal" aria-hidden="true">
        <div class="graph-fullscreen-card" role="dialog" aria-modal="true" aria-label="Causal graph fullscreen">
            <div class="graph-fullscreen-head">
                <strong>Causal Graph · Expanded view</strong>
                <button class="header-link" id="close-graph-fullscreen">Close</button>
            </div>
            <div class="graph-fullscreen-body" id="graph-fullscreen-content"></div>
        </div>
    </div>

    <div id="telemetry-modal" class="telemetry-modal" aria-hidden="true">
        <div class="telemetry-card" role="dialog" aria-modal="true" aria-label="Telemetry warning details">
            <div class="telemetry-head">
                <strong>Telemetry warning details</strong>
                <button class="header-link" id="close-telemetry-modal">Close</button>
            </div>
            <div class="telemetry-grid">
                <div class="telemetry-block"><h4>Error</h4><div id="telemetry-detail-error">—</div></div>
                <div class="telemetry-block"><h4>Root cause</h4><div id="telemetry-detail-reason">—</div></div>
                <div class="telemetry-block"><h4>Deep dive</h4><div id="telemetry-detail-deep">—</div></div>
                <div class="telemetry-block"><h4>Guidance</h4><div id="telemetry-detail-guide">—</div></div>
                <div class="telemetry-block"><h4>What to do</h4><div id="telemetry-detail-action">—</div></div>
            </div>
        </div>
    </div>

    <script>
        // Centralized frontend state. Keeps selected agent, active tab, graph viewport and latest payloads.
        const store = {
            agents: new Map(),
            insights: null,
            selectedAgent: null,
            drilldown: null,
            drilldownByAgent: new Map(),
            drilldownCacheTtlMs: 12000,
            drilldownLoadingAgent: null,
            drilldownAbortController: null,
            activeTab: 'decisions',
            graphViewport: { scale: 1, tx: 0, ty: 0 },
            graphViewportFullscreen: { scale: 1, tx: 0, ty: 0 },
            graphNodeWeights: { graph: {}, graphfs: {} },
            graphInteractionTs: 0,
            nodeDetails: null,
            graphJump: null,
            docsIndex: [],
            docsCurrent: null,
            docsCurrentAnchor: null,
            docsCatalog: [],
            docsPayloadByName: {},
            overviewCurrent: null,
            overviewSelectedAgent: null,
            overviewDeepByAgent: {},
            overviewBacklink: null,
            telemetryStatus: null,
            agentTelemetryHistory: {},
            refreshInFlight: false,
            refreshQueued: false,
            drilldownRequestSeq: 0,
        };

        const renderState = {
            queued: false,
            dirty: {
                agents: true,
                interactions: true,
                kpi: true,
                drilldown: true,
                overview: true,
                refresh: true,
            },
            agentSignatures: new Map(),
            interactionsSignature: '',
            kpiSignature: '',
            drilldownSignature: '',
            overviewSignature: '',
        };

        // Escape helper for safe HTML interpolation.
        function esc(value) {
            const s = String(value ?? '');
            return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;');
        }

        function markContentUpdate(node) {
            if (!node) return;
            const now = Date.now();
            const lastTs = Number(node.dataset.contentUpdatedTs || 0);
            if ((now - lastTs) < 160) return;
            node.dataset.contentUpdatedTs = String(now);
            node.classList.add('content-updated');
            if (node._contentUpdatedTimer) {
                clearTimeout(node._contentUpdatedTimer);
            }
            node._contentUpdatedTimer = setTimeout(() => {
                node.classList.remove('content-updated');
            }, 280);
        }

        function agentColor(name) {
            const key = String(name || '').trim().toLowerCase();
            if (!key) return 'hsl(220 74% 62%)';

            let hash = 0;
            for (let i = 0; i < key.length; i += 1) {
                hash = ((hash << 5) - hash) + key.charCodeAt(i);
                hash |= 0;
            }
            const hue = Math.abs(hash) % 360;
            return `hsl(${hue} 74% 62%)`;
        }

        function agentBadge(name, compact = false) {
            const label = String(name || 'unknown').trim() || 'unknown';
            const color = agentColor(label);
            const compactClass = compact ? 'compact' : '';
            return `<span class="agent-badge ${compactClass}" style="--agent-accent:${esc(color)};">${esc(label)}</span>`;
        }

        function safeDomKey(value) {
            return String(value || 'unknown').toLowerCase().replace(/[^a-z0-9_-]+/g, '-');
        }

        function normalizeTextList(value) {
            if (!Array.isArray(value)) return [];
            return value
                .map((item) => String(item ?? '').replace(/\s+/g, ' ').trim())
                .filter(Boolean);
        }

        function shortText(value, maxChars = 140) {
            const text = String(value ?? '').replace(/\s+/g, ' ').trim();
            if (!text) return '—';
            if (text.length <= maxChars) return text;
            return `${text.slice(0, maxChars - 1)}…`;
        }

        function renderCollapsibleTraceList(label, rawItems, options = {}) {
            const items = normalizeTextList(rawItems);
            if (!items.length) {
                return `<div class="small muted"><strong>${esc(label)}:</strong> —</div>`;
            }

            const previewLimit = Number.isFinite(Number(options.previewLimit)) ? Number(options.previewLimit) : 2;
            const preview = items.slice(0, Math.max(1, previewLimit)).map((item) => shortText(item, 120)).join(' · ');
            const previewTail = items.length > previewLimit ? ` · +${items.length - previewLimit} more` : '';
            const openAttr = options.open ? ' open' : '';

            return `
                <details class="trace-expand"${openAttr}>
                    <summary><strong>${esc(label)}:</strong> ${esc(preview + previewTail)}</summary>
                    <ul class="trace-list">
                        ${items.map((item) => `<li>${esc(item)}</li>`).join('')}
                    </ul>
                </details>
            `;
        }

        function formatRootCauseItems(rootCauses) {
            if (!Array.isArray(rootCauses)) return [];
            return rootCauses
                .map((entry) => {
                    if (!entry || typeof entry !== 'object') return '';
                    const file = String(entry.file || '').trim();
                    const anchors = Array.isArray(entry.anchors)
                        ? entry.anchors.map((item) => String(item || '').trim()).filter(Boolean)
                        : [];
                    if (!file && !anchors.length) return '';
                    if (!anchors.length) return file || '';
                    return `${file}: ${anchors.join(', ')}`;
                })
                .filter(Boolean);
        }

        function basenameFromPath(path) {
            const text = String(path || '').trim();
            if (!text) return '';
            const parts = text.split('/').filter(Boolean);
            return parts.length ? parts[parts.length - 1] : text;
        }

        function splitEvidenceClauses(items, maxItems = 8) {
            const out = [];
            for (const item of normalizeTextList(items)) {
                const clauses = item
                    .split(/\s+[·|]\s+|;\s+|\.\s+(?=[A-ZÀ-Ý])/)
                    .map((x) => x.trim())
                    .filter(Boolean);
                if (!clauses.length) {
                    out.push(item);
                } else {
                    out.push(...clauses);
                }
                if (out.length >= maxItems) break;
            }
            return out.slice(0, maxItems);
        }

        function extractReasoningChunks(row) {
            const rawDecision = String(row?.decision || '').replace(/\s+/g, ' ').trim();
            let speaker = '';
            let decisionText = rawDecision;

            const speakerMatch = decisionText.match(/^([a-z_][a-z0-9_-]{1,24})\s*:\s*/i);
            if (speakerMatch) {
                speaker = speakerMatch[1];
                decisionText = decisionText.slice(speakerMatch[0].length).trim();
            }

            let decisionTag = '';
            const tagMatch = decisionText.match(/\b([A-Z][A-Z0-9_]{2,})$/);
            if (tagMatch) {
                decisionTag = tagMatch[1];
                decisionText = decisionText.slice(0, decisionText.length - decisionTag.length).trim();
            }

            const decisionParts = decisionText.split(/\s+-\s+/).map((x) => x.trim()).filter(Boolean);
            const outcome = decisionParts[0] || decisionText || '—';
            const signals = decisionParts.slice(1);

            const whyItems = normalizeTextList(row?.why || []);
            const trigger = whyItems.filter((x) => /trigger|cron|schedule|heartbeat|broadcast|request|esecuzione/i.test(x));
            const constraints = whyItems.filter((x) => /constraint|goal|objective|policy|limit|soul|operations|workspace document/i.test(x));
            const context = whyItems.filter((x) => !trigger.includes(x) && !constraints.includes(x));

            const evidence = splitEvidenceClauses(row?.evidence || [], 8);

            const sourceFiles = (Array.isArray(row?.root_causes) ? row.root_causes : [])
                .map((entry) => {
                    if (!entry || typeof entry !== 'object') return '';
                    const file = String(entry.file || '').trim();
                    const fileName = basenameFromPath(file);
                    const anchors = Array.isArray(entry.anchors)
                        ? entry.anchors.map((x) => String(x || '').trim()).filter(Boolean)
                        : [];
                    if (!fileName && !anchors.length) return '';
                    if (!anchors.length) return fileName || '';
                    const anchorPreview = anchors.slice(0, 3).join(', ');
                    const extra = anchors.length > 3 ? ` (+${anchors.length - 3})` : '';
                    return `${fileName}: ${anchorPreview}${extra}`;
                })
                .filter(Boolean)
                .slice(0, 8);

            return {
                speaker,
                decisionTag,
                outcome,
                signals,
                trigger,
                constraints,
                context,
                evidence,
                sourceFiles,
            };
        }

        function renderHumanReasoning(row) {
            const chunks = extractReasoningChunks(row || {});

            const outcomeText = chunks.decisionTag
                ? `${chunks.outcome} (${chunks.decisionTag})`
                : chunks.outcome;

            const triggerText = shortText(chunks.trigger[0] || chunks.context[0] || '—', 110);
            const constraintsText = shortText(chunks.constraints[0] || '—', 100);
            const signalText = shortText(chunks.signals[0] || '—', 100);
            const evidenceText = shortText(chunks.evidence[0] || '—', 110);
            const sourceText = shortText(chunks.sourceFiles[0] || '—', 100);

            const detailSections = [
                { label: 'Signals', items: chunks.signals },
                { label: 'Trigger', items: chunks.trigger },
                { label: 'Constraints', items: chunks.constraints },
                { label: 'Evidence', items: chunks.evidence },
                { label: 'Sources', items: chunks.sourceFiles },
            ].filter((entry) => Array.isArray(entry.items) && entry.items.length > 1);

            const detailsHtml = detailSections.length ? `
                <details class="reasoning-details">
                    <summary>Expand reasoning details (${detailSections.length} sections)</summary>
                    ${detailSections.map((entry) => `
                        <div class="reasoning-details-row">
                            <span class="reasoning-details-label">${esc(entry.label)}</span>
                            <ul class="reasoning-compact-list">${entry.items.map((item) => `<li>${esc(item)}</li>`).join('')}</ul>
                        </div>
                    `).join('')}
                </details>
            ` : '';

            return `
                <div class="reasoning-compact">
                    <table class="reasoning-table" role="presentation">
                        <tbody>
                            <tr>
                                <th>Outcome</th>
                                <td>${esc(outcomeText)} ${chunks.decisionTag ? `<span class="reason-tag">${esc(chunks.decisionTag)}</span>` : ''}</td>
                            </tr>
                            ${chunks.speaker ? `<tr><th>Speaker</th><td>${esc(chunks.speaker)}</td></tr>` : ''}
                            <tr><th>Signal</th><td>${esc(signalText)}</td></tr>
                            <tr><th>Trigger</th><td>${esc(triggerText)}</td></tr>
                            <tr><th>Rule</th><td>${esc(constraintsText)}</td></tr>
                            <tr><th>Evidence</th><td>${esc(evidenceText)}</td></tr>
                            <tr><th>Source</th><td>${esc(sourceText)}</td></tr>
                        </tbody>
                    </table>
                    ${detailsHtml}
                </div>
            `;
        }

        function parseTokenCount(item) {
            const rawCore = item?.raw_core || {};
            const raw = item?.raw || {};

            const directCandidates = [
                rawCore.totalTokens,
                rawCore.total_tokens,
                raw.totalTokens,
                raw.total_tokens,
                rawCore?.usage?.totalTokens,
                rawCore?.usage?.total_tokens,
                raw?.usage?.totalTokens,
                raw?.usage?.total_tokens,
            ];
            for (const direct of directCandidates) {
                const n = Number(direct);
                if (Number.isFinite(n)) return n;
            }

            const messages = Array.isArray(item?.recent_messages) ? item.recent_messages : [];
            for (const msg of messages) {
                const m = String(msg || '').match(/tokens\s*[=:]\s*([0-9]+)/i);
                if (m) return Number(m[1]);
            }
            return null;
        }

        function parseTimestampMs(value) {
            if (value == null) return null;
            const num = Number(value);
            if (Number.isFinite(num)) {
                if (num > 1e12) return num;
                if (num > 1e9) return num * 1000;
            }

            const text = String(value || '').trim();
            if (!text) return null;
            const parsed = Date.parse(text);
            if (Number.isFinite(parsed)) return parsed;

            const m = text.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
            if (!m) return null;
            const now = new Date();
            const hh = Number(m[1]);
            const mm = Number(m[2]);
            const ss = Number(m[3] || 0);
            const candidate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hh, mm, ss, 0).getTime();
            return Number.isFinite(candidate) ? candidate : null;
        }

        function formatDecisionTime(tsValue, tsMs) {
            const ms = Number.isFinite(tsMs) ? tsMs : parseTimestampMs(tsValue);
            if (!Number.isFinite(ms)) {
                return {
                    strong: 'Unknown time',
                    raw: String(tsValue || '—'),
                };
            }

            const dt = new Date(ms);
            return {
                strong: dt.toLocaleString(undefined, {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                }),
                raw: String(tsValue || dt.toISOString()),
            };
        }

        function getAgentFreshness(item) {
            const rawCandidates = [
                item?.last_seen_ts,
                item?.last_seen,
                item?.raw_core?.last_seen,
                item?.raw?.last_seen,
            ];
            let ts = null;
            for (const candidate of rawCandidates) {
                ts = parseTimestampMs(candidate);
                if (Number.isFinite(ts)) break;
            }

            if (!Number.isFinite(ts)) {
                return { className: 'bad', label: 'unknown', bucket: 'unknown', title: 'No valid heartbeat timestamp' };
            }

            const ageSec = Math.max(0, Math.floor((Date.now() - ts) / 1000));
            if (ageSec <= 40) {
                return { className: 'live', label: 'live', bucket: 'live', title: `Heartbeat ${ageSec}s ago` };
            }
            if (ageSec <= 180) {
                return { className: 'warn', label: 'delayed', bucket: 'delayed', title: `Heartbeat ${ageSec}s ago` };
            }
            return { className: 'bad', label: 'stale', bucket: 'stale', title: `Heartbeat ${ageSec}s ago` };
        }

        function setKpiValue(key, value) {
            const node = document.querySelector(`openclaw-kpi-card[data-kpi-key="${key}"]`);
            if (!node || typeof node.setValue !== 'function') return;
            node.setValue(value);
        }

        class OpenClawKpiCard extends HTMLElement {
            constructor() {
                super();
                this._value = '0';
                this._bound = false;
            }

            connectedCallback() {
                if (!this._bound) {
                    this.setAttribute('role', 'button');
                    this.setAttribute('tabindex', '0');
                    this.addEventListener('click', (event) => {
                        const helpBtn = event.target.closest('.help-btn[data-doc]');
                        if (!helpBtn) return;
                        event.preventDefault();
                        event.stopImmediatePropagation();
                        openDocsModal(helpBtn.dataset.doc || 'INDEX.md', helpBtn.dataset.docAnchor || null);
                    });
                    this._bound = true;
                }
                this.render();
            }

            setValue(value) {
                const next = String(value ?? 0);
                if (next === this._value) return;
                this._value = next;
                const valueNode = this.querySelector('.value');
                if (valueNode) valueNode.textContent = next;
                markContentUpdate(this);
            }

            render() {
                const label = this.getAttribute('data-label') || 'Metric';
                const doc = this.getAttribute('data-doc') || 'INDEX.md';
                const anchor = this.getAttribute('data-doc-anchor') || '';
                this.innerHTML = `<div class="label">${esc(label)} <button class="help-btn micro" data-doc="${esc(doc)}" data-doc-anchor="${esc(anchor)}" title="Meaning of this KPI">?</button></div><div class="value">${esc(this._value)}</div>`;
            }
        }

        class OpenClawStreamList extends HTMLElement {
            constructor() {
                super();
                this._rows = [];
                this._signature = '';
            }

            setRows(rows) {
                const normalized = Array.isArray(rows) ? rows : [];
                const first = normalized[0] || {};
                const last = normalized[normalized.length - 1] || {};
                const signature = [
                    normalized.length,
                    first.id || first.ts || first.text || '',
                    last.id || last.ts || last.text || '',
                ].join('|');
                if (signature === this._signature) return;
                this._signature = signature;
                this._rows = normalized;
                this.render();
            }

            render() {
                const mode = this.getAttribute('data-mode') || 'ua';
                if (!this._rows.length) {
                    this.innerHTML = mode === 'ua'
                        ? '<div class="row">No user/agent interactions detected.</div>'
                        : '<div class="row">No agent/agent interactions detected.</div>';
                    return;
                }

                if (mode === 'aa') {
                    this.innerHTML = this._rows.map((it) => `
                        <div class="row">
                            <div>${agentBadge(it.source, true)} → ${agentBadge(it.target, true)}</div>
                            <div>${esc(it.text || '')}</div>
                            <div class="when">${esc(it.ts || '')}</div>
                        </div>
                    `).join('');
                    markContentUpdate(this);
                    return;
                }

                this.innerHTML = this._rows.map((it) => `
                    <div class="row">
                        <div>${agentBadge(it.agent, true)} · ${esc(it.actor || 'unknown')}</div>
                        <div>${esc(it.text || '')}</div>
                        <div class="when">${esc(it.ts || '')}</div>
                    </div>
                `).join('');
                markContentUpdate(this);
            }
        }

        if (!customElements.get('openclaw-kpi-card')) {
            customElements.define('openclaw-kpi-card', OpenClawKpiCard);
        }
        if (!customElements.get('openclaw-stream-list')) {
            customElements.define('openclaw-stream-list', OpenClawStreamList);
        }

        function formatTokenCompact(value) {
            if (!Number.isFinite(value)) return 'n/a';
            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;
            if (value >= 1000) return `${(value / 1000).toFixed(1)}k`;
            return `${Math.round(value)}`;
        }

        function pushAgentTelemetryPoint(item) {
            const agent = String(item?.agent || '').trim();
            if (!agent) return;
            const tokens = parseTokenCount(item);
            const ts = Date.now();
            const key = safeDomKey(agent);
            const history = store.agentTelemetryHistory[key] || [];
            history.push({
                ts,
                tokens: Number.isFinite(tokens) ? tokens : null,
            });
            store.agentTelemetryHistory[key] = history.slice(-48);
        }

        function drawMiniBars(canvasId, rows, pick, color) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const width = canvas.width;
            const height = canvas.height;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            ctx.clearRect(0, 0, width, height);
            const vals = rows.map((r) => pick(r)).filter((v) => Number.isFinite(v));
            if (!vals.length) {
                ctx.strokeStyle = 'rgba(169,183,217,.35)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(4, height - 4);
                ctx.lineTo(width - 4, 4);
                ctx.stroke();
                return;
            }

            const min = Math.min(...vals);
            const max = Math.max(...vals);
            const range = Math.max(1, max - min);
            const bars = rows.map((row) => pick(row)).filter((v) => Number.isFinite(v));
            if (!bars.length) return;

            const barWidth = Math.max(2, Math.floor((width - 8) / Math.max(1, bars.length)) - 1);
            ctx.fillStyle = color;
            bars.forEach((value, index) => {
                const normalized = (value - min) / range;
                const h = Math.max(2, normalized * (height - 8));
                const x = 4 + index * (barWidth + 1);
                const y = height - 4 - h;
                ctx.globalAlpha = 0.9;
                ctx.fillRect(x, y, barWidth, h);
            });
            ctx.globalAlpha = 1;
        }

        function renderTelemetryCheck(rows) {
            const button = document.getElementById('telemetry-warning-btn');
            if (!button) return;
            const report = store.insights?.telemetry_gaps || null;
            const summary = report?.summary || null;
            const total = Number(summary?.agents ?? rows.length) || 0;
            const tokOk = Number(summary?.tokens_numeric ?? rows.filter((r) => Number.isFinite(parseTokenCount(r))).length) || 0;

            button.classList.remove('bad');
            if (!total) {
                store.telemetryStatus = null;
                button.classList.add('hidden');
                return;
            }

            const missingAgents = Array.isArray(report?.agents) ? report.agents : [];
            const missingTokenAgents = missingAgents
                .filter((it) => Array.isArray(it?.missing) && it.missing.includes('tokens'))
                .map((it) => String(it?.agent || ''))
                .filter(Boolean);
            const missingPreview = missingTokenAgents.slice(0, 5).join(', ');

            if (tokOk === 0) {
                store.telemetryStatus = {
                    severity: 'bad',
                    error: 'No numeric token telemetry available',
                    reason: `0/${total} agents expose numeric token fields.${missingPreview ? ` Missing: ${missingPreview}.` : ''}`,
                    deep: 'The mini token chart and token trend analysis require numeric token counters in live payloads.',
                    guide: 'Check the agent payload schema and ensure token counters are emitted as numeric fields.',
                    action: 'Update the emitting agents to include token metrics, then refresh the dashboard.',
                };
                button.classList.remove('hidden');
                button.classList.add('bad');
                return;
            }

            if (tokOk < total) {
                store.telemetryStatus = {
                    severity: 'warn',
                    error: 'Partial token telemetry coverage',
                    reason: `Only ${tokOk}/${total} agents provide numeric token data.${missingPreview ? ` Missing: ${missingPreview}.` : ''}`,
                    deep: 'Charts are correct for agents with data, but cross-agent comparisons are incomplete until missing metrics are provided.',
                    guide: 'Inspect `insights.telemetry_gaps` and align token fields across all agent payloads.',
                    action: 'Add token metrics for missing agents and keep field names/types consistent.',
                };
                button.classList.remove('hidden');
                return;
            }

            store.telemetryStatus = null;
            button.classList.add('hidden');
        }

        function openTelemetryModal() {
            const modal = document.getElementById('telemetry-modal');
            if (!modal) return;
            const status = store.telemetryStatus;
            if (!status) return;

            document.getElementById('telemetry-detail-error').textContent = status.error || '—';
            document.getElementById('telemetry-detail-reason').textContent = status.reason || '—';
            document.getElementById('telemetry-detail-deep').textContent = status.deep || '—';
            document.getElementById('telemetry-detail-guide').textContent = status.guide || '—';
            document.getElementById('telemetry-detail-action').textContent = status.action || '—';

            modal.classList.add('open');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeTelemetryModal() {
            const modal = document.getElementById('telemetry-modal');
            if (!modal) return;
            modal.classList.remove('open');
            modal.setAttribute('aria-hidden', 'true');
        }

        function renderAgentTelemetryCharts(rows) {
            rows.forEach((item) => pushAgentTelemetryPoint(item));
            requestAnimationFrame(() => {
                rows.forEach((item) => {
                    const key = safeDomKey(item.agent);
                    const history = store.agentTelemetryHistory[key] || [];
                    drawMiniBars(`mini-tok-${key}`, history, (r) => r.tokens, '#16c784');
                });
            });
        }

        // Map backend status values to semantic color classes.
        function statusClass(status) {
            const s = String(status || '').toLowerCase();
            if (s.includes('ok') || s.includes('active')) return 'status-ok';
            if (s.includes('attention') || s.includes('observed')) return 'status-warn';
            return 'status-bad';
        }

        function setTab(tab) {
            store.activeTab = tab;
            document.querySelectorAll('.tab').forEach((node) => {
                node.classList.toggle('active', node.dataset.tab === tab);
            });
            renderActiveTabHelp();
            scheduleRender({ drilldown: true, refresh: true });
        }

        function getActiveTabHelp(tab) {
            const map = {
                decisions: { label: 'Why decisions', anchor: '03-ui-ux-guide.md-why-decisions-tab' },
                soul: { label: 'SOUL/file derivation', anchor: '03-ui-ux-guide.md-soul-file-derivation-tab' },
                graph: { label: 'Causal Graph', anchor: '03-ui-ux-guide.md-causal-graph-tab' },
                cron_timeline: { label: 'Cron timeline', anchor: '03-ui-ux-guide.md-cron-timeline-tab' },
                timeline: { label: 'Full timeline', anchor: '03-ui-ux-guide.md-full-timeline-tab' },
                overview: { label: 'Overview', anchor: '03-ui-ux-guide.md-overview-tab' },
            };
            return map[tab] || map.decisions;
        }

        function renderActiveTabHelp() {
            const row = getActiveTabHelp(store.activeTab);
            const label = document.getElementById('active-tab-help-text');
            const btn = document.getElementById('active-tab-help');
            if (label) label.textContent = `Active tab guide: ${row.label}.`;
            if (btn) {
                btn.setAttribute('data-doc', '03-ui-ux-guide.md');
                btn.setAttribute('data-doc-anchor', row.anchor);
            }
        }

        function renderBreadcrumbCrumb(crumb, isActive = false) {
            if (!crumb || !crumb.label) return '';
            const action = crumb.action || '';
            const value = crumb.value || '';
            const strong = crumb.strong ? 'crumb-strong' : '';
            const active = isActive ? 'active' : '';
            const labelHtml = action === 'agent'
                ? agentBadge(value || crumb.label, true)
                : `<span class="${strong}">${esc(crumb.label)}</span>`;
            if (!action) {
                return labelHtml;
            }

            let hint = '';
            if (action === 'swarm') hint = 'Reset focus and return to swarm-level view';
            else if (action === 'agent') hint = `Open deep investigation for ${crumb.label}`;
            else if (action === 'tab') hint = `Jump to tab: ${crumb.label}`;
            else if (action === 'overview-link') hint = 'Return to decisions linked from overview level-3';
            else if (action === 'decision') hint = `Focus linked decision ${crumb.label}`;
            else if (action === 'node') hint = `Open graph node ${crumb.label}`;

            if (action === 'agent') {
                return `<span class="agent-badge compact nav-action" style="--agent-accent:${esc(agentColor(value || crumb.label))};" data-bc-action="${esc(action)}" data-bc-value="${esc(value)}" title="${esc(hint)}" aria-label="${esc(hint)}" role="button" tabindex="0">${esc(value || crumb.label)}</span>`;
            }

            return `<button class="crumb-btn ${active}" data-bc-action="${esc(action)}" data-bc-value="${esc(value)}" title="${esc(hint)}" aria-label="${esc(hint)}">${labelHtml}</button>`;
        }

        async function handleBreadcrumbAction(action, value) {
            if (action === 'swarm') {
                store.selectedAgent = null;
                store.drilldown = null;
                store.nodeDetails = null;
                store.graphJump = null;
                store.overviewBacklink = null;
                render();
                return;
            }

            if (action === 'agent') {
                if (value) await openDrilldown(value);
                return;
            }

            if (action === 'tab') {
                if (value) setTab(value);
                return;
            }

            if (action === 'overview-link' || action === 'decision') {
                setTab('decisions');
                return;
            }

            if (action === 'node') {
                setTab('graph');
                if (value) await openNodeDetails(value);
            }
        }

        async function fetchJsonWithTimeout(url, timeoutMs = 8000) {
            const controller = new AbortController();
            const timer = setTimeout(() => controller.abort(), timeoutMs);
            try {
                const response = await fetch(url, { signal: controller.signal });
                if (!response.ok) return null;
                return await response.json();
            } finally {
                clearTimeout(timer);
            }
        }

        async function loadDocsIndex() {
            try {
                const payload = await fetchJsonWithTimeout('/docs/index');
                if (!payload) return [];
                const docs = Array.isArray(payload.docs) ? payload.docs : [];
                store.docsIndex = docs;
                return docs;
            } catch (error) {
                console.error('docs index error', error);
                return [];
            }
        }

        function slugifyHeading(text) {
            return String(text || '')
                .toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/[^a-z0-9\s-]/g, '')
                .trim()
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-');
        }

        function stripMarkdownInline(text) {
            return String(text || '')
                .replace(/`([^`]+)`/g, '$1')
                .replace(/\*\*([^*]+)\*\*/g, '$1')
                .replace(/\*([^*]+)\*/g, '$1')
                .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1')
                .replace(/<[^>]*>/g, '')
                .trim();
        }

        function extractDocSections(markdownText) {
            const lines = String(markdownText || '').split(/\r?\n/);
            const h1 = [];
            const h2 = [];
            for (const line of lines) {
                const m1 = line.match(/^\s*#\s+(.+)\s*$/);
                if (m1) {
                    const label = stripMarkdownInline(m1[1]);
                    if (label) h1.push(label);
                    continue;
                }
                const m2 = line.match(/^\s*##\s+(.+)\s*$/);
                if (m2) {
                    const label = stripMarkdownInline(m2[1]);
                    if (label) h2.push(label);
                }
            }
            return { h1, h2 };
        }

        function markdownToHtml(markdownText) {
            const raw = String(markdownText || '');
            const parsed = marked.parse(raw, {
                gfm: true,
                breaks: false,
                async: false,
            });
            return DOMPurify.sanitize(parsed, {
                USE_PROFILES: { html: true },
            });
        }

        function enhanceDocHeadings(container, docName) {
            const headingNodes = container.querySelectorAll('h1, h2');
            const used = new Set();
            headingNodes.forEach((node, index) => {
                const label = node.textContent || '';
                const base = slugifyHeading(label) || `section-${index + 1}`;
                let id = `${docName}-${base}`;
                let suffix = 2;
                while (used.has(id)) {
                    id = `${docName}-${base}-${suffix}`;
                    suffix += 1;
                }
                used.add(id);
                node.id = id;
                node.classList.add('docs-anchor-target');
            });
        }

        function highlightCodeBlocks(container) {
            container.querySelectorAll('pre code').forEach((node) => {
                try {
                    hljs.highlightElement(node);
                } catch (error) {
                    console.error('highlight error', error);
                }
            });
        }

        function renderDocsMenu() {
            const menu = document.getElementById('docs-menu');
            const rows = Array.isArray(store.docsCatalog) ? store.docsCatalog : [];
            if (!rows.length) {
                menu.innerHTML = '<div class="docs-menu-empty">No documentation sections found.</div>';
                return;
            }

            menu.innerHTML = rows.map((row) => {
                const isDocActive = String(store.docsCurrent || '') === String(row.doc || '');
                const mainActive = isDocActive && !store.docsCurrentAnchor ? 'active' : '';
                const children = (row.children || []).map((child) => {
                    const childActive = isDocActive && String(store.docsCurrentAnchor || '') === String(child.id || '') ? 'active' : '';
                    return `<button class="docs-menu-btn sub ${childActive}" data-doc-name="${esc(row.doc || '')}" data-doc-anchor="${esc(child.id || '')}">${esc(child.label || '')}</button>`;
                }).join('');

                return `
                    <div class="docs-tree-group">
                        <button class="docs-menu-btn main ${mainActive}" data-doc-name="${esc(row.doc || '')}">${esc(row.title || 'Section')}</button>
                        <div class="docs-subtree">${children || ''}</div>
                    </div>
                `;
            }).join('');

            menu.querySelectorAll('[data-doc-name]').forEach((node) => {
                node.addEventListener('click', () => {
                    const docName = node.getAttribute('data-doc-name') || '';
                    const anchor = node.getAttribute('data-doc-anchor') || null;
                    openDocsModal(docName, anchor);
                });
            });
        }

        async function fetchDocContent(docName) {
            const target = String(docName || '').trim();
            if (!target) return null;
            if (store.docsPayloadByName[target]) return store.docsPayloadByName[target];
            try {
                const payload = await fetchJsonWithTimeout(`/docs/content/${encodeURIComponent(target)}`);
                if (!payload) return null;
                if (payload && payload.found) {
                    store.docsPayloadByName[target] = payload;
                }
                return payload;
            } catch (error) {
                console.error('doc content error', error);
                return null;
            }
        }

        async function buildDocsCatalog() {
            if (store.docsCatalog.length) return store.docsCatalog;
            const rows = Array.isArray(store.docsIndex) ? store.docsIndex : [];
            if (!rows.length) return [];

            const catalog = [];
            let untitledCount = 0;
            for (const row of rows) {
                const docName = String(row.name || '').trim();
                if (!docName) continue;
                const payload = await fetchDocContent(docName);
                if (!payload || !payload.found) continue;

                const sections = extractDocSections(payload.content || '');
                let title = sections.h1[0] || '';
                if (!title) {
                    untitledCount += 1;
                    title = `Section ${untitledCount}`;
                }
                const children = sections.h2.slice(0, 60).map((label) => ({
                    label,
                    id: `${docName}-${slugifyHeading(label)}`,
                }));

                catalog.push({
                    doc: docName,
                    title,
                    children,
                });
            }

            store.docsCatalog = catalog;
            return catalog;
        }

        function closeDocsModal() {
            const modal = document.getElementById('docs-modal');
            modal.classList.remove('open');
            modal.setAttribute('aria-hidden', 'true');
        }

        function closeOverviewModal() {
            const modal = document.getElementById('overview-modal');
            modal.classList.remove('open');
            modal.setAttribute('aria-hidden', 'true');
            store.overviewCurrent = null;
            store.overviewSelectedAgent = null;
            renderState.overviewSignature = '';
        }

        function openGraphFullscreenModal() {
            const modal = document.getElementById('graph-fullscreen-modal');
            const content = document.getElementById('graph-fullscreen-content');
            const graph = store.drilldown?.depth?.causal_graph || { nodes: [], edges: [] };
            if (!modal || !content) return;

            store.graphViewportFullscreen = {
                scale: store.graphViewport.scale,
                tx: store.graphViewport.tx,
                ty: store.graphViewport.ty,
            };

            content.innerHTML = renderCausalGraph(graph, { prefix: 'graphfs', expandable: false });
            modal.classList.add('open');
            modal.setAttribute('aria-hidden', 'false');
            initGraphViewport('graphfs');
        }

        function closeGraphFullscreenModal() {
            const modal = document.getElementById('graph-fullscreen-modal');
            const content = document.getElementById('graph-fullscreen-content');
            if (!modal || !content) return;

            modal.classList.remove('open');
            modal.setAttribute('aria-hidden', 'true');
            content.innerHTML = '';

            store.graphViewport = {
                scale: store.graphViewportFullscreen.scale,
                tx: store.graphViewportFullscreen.tx,
                ty: store.graphViewportFullscreen.ty,
            };
            applyGraphTransform('graph');
            initGraphViewport('graph');
        }

        function renderOverviewLines(lines) {
            if (!Array.isArray(lines) || !lines.length) {
                return '<div class="overview-detail"><h4>Detail</h4><div>No records available.</div></div>';
            }
            return `<ul class="overview-lines">${lines.map((line) => `<li>${esc(line)}</li>`).join('')}</ul>`;
        }

        function buildOverviewEntries(metricKey) {
            const insights = store.insights || {};
            const agents = Array.isArray(insights.agents) ? insights.agents : [];
            const cronByAgent = insights?.cron?.by_agent || {};
            const ua = Array.isArray(insights?.interactions?.user_agent) ? insights.interactions.user_agent : [];
            const aa = Array.isArray(insights?.interactions?.agent_agent) ? insights.interactions.agent_agent : [];

            if (metricKey === 'agents') {
                return agents
                    .map((agent) => ({
                        agent: agent.agent || 'unknown',
                        lines: [
                            `Status: ${agent.status || 'unknown'}`,
                            `Task: ${agent.task || '—'}`,
                            `Cron jobs: ${agent.cron_jobs ?? 0}`,
                            `Last event: ${agent.last_seen || 'n/a'}`,
                        ],
                    }))
                    .sort((a, b) => a.agent.localeCompare(b.agent));
            }

            if (metricKey === 'cron') {
                return Object.entries(cronByAgent)
                    .map(([agent, rows]) => ({
                        agent,
                        lines: (rows || []).map((job) => `${job.name || 'job'} · status=${job.last_status || 'unknown'} · next=${job.next_run_at || 'n/a'} · interrupted=${job.interrupted ? 'yes' : 'no'}`),
                    }))
                    .sort((a, b) => (b.lines.length - a.lines.length) || a.agent.localeCompare(b.agent));
            }

            if (metricKey === 'user_agent') {
                const bucket = {};
                ua.forEach((row) => {
                    const key = row.agent || 'unknown';
                    bucket[key] = bucket[key] || [];
                    bucket[key].push(`${row.ts || 'n/a'} · ${row.actor || 'user'} · ${row.text || ''}`);
                });
                return Object.entries(bucket)
                    .map(([agent, lines]) => ({ agent, lines }))
                    .sort((a, b) => (b.lines.length - a.lines.length) || a.agent.localeCompare(b.agent));
            }

            if (metricKey === 'agent_agent') {
                const bucket = {};
                aa.forEach((row) => {
                    const source = row.source || 'unknown';
                    bucket[source] = bucket[source] || [];
                    bucket[source].push(`${row.ts || 'n/a'} · to ${row.target || 'unknown'} · ${row.text || ''}`);
                });
                return Object.entries(bucket)
                    .map(([agent, lines]) => ({ agent, lines }))
                    .sort((a, b) => (b.lines.length - a.lines.length) || a.agent.localeCompare(b.agent));
            }

            const interruptedByAgent = {};
            Object.entries(cronByAgent).forEach(([agent, rows]) => {
                (rows || []).forEach((job) => {
                    if (!job?.interrupted) return;
                    interruptedByAgent[agent] = interruptedByAgent[agent] || [];
                    interruptedByAgent[agent].push(`${job.name || 'job'} · status=${job.last_status || 'unknown'} · last=${job.last_run_at || 'n/a'} · next=${job.next_run_at || 'n/a'}`);
                });
            });
            return Object.entries(interruptedByAgent)
                .map(([agent, lines]) => ({ agent, lines }))
                .sort((a, b) => (b.lines.length - a.lines.length) || a.agent.localeCompare(b.agent));
        }

        function renderOverviewAgentDeep(agentName) {
            const payload = store.overviewDeepByAgent[agentName];
            if (!payload) {
                return `
                    <div class="overview-detail">
                        <h4>Level 2 drilldown</h4>
                        <div>Press <strong>Load level-2 drilldown</strong> to fetch complete analysis for this agent.</div>
                    </div>
                `;
            }
            if (!payload.found) {
                return '<div class="overview-detail"><h4>Level 2 drilldown</h4><div>Drilldown payload not available for selected agent.</div></div>';
            }

            const depth = payload.depth || {};
            const overview = depth.overview || {};
            const decisions = Array.isArray(depth.decision_trace) ? depth.decision_trace : [];
            const cronTimeline = Array.isArray(depth.cron_timeline) ? depth.cron_timeline : [];
            const roots = Array.isArray(depth.context_roots) ? depth.context_roots : [];

            const decisionRows = decisions.slice(0, 10).map((row, index) => ({
                index,
                ts: row.ts || 'n/a',
                confidence: row.confidence || 'n/a',
                text: row.decision || '—',
            }));
            const cronLines = cronTimeline.slice(-10).map((row) => `${row.ts || 'n/a'} · ${row.job || 'job'} · ${row.status || row.kind || 'event'} · ${row.summary || '—'}`);
            const rootLines = roots.slice(0, 8).map((row) => `${row.file || 'file'} · anchors=${(row.matched_anchors || []).length}`);
            const decisionHtml = decisionRows.length
                ? `<ul class="overview-decision-list">${decisionRows.map((row) => `
                    <li class="overview-decision-item">
                        <div class="overview-decision-meta">${esc(row.ts)} · confidence=${esc(row.confidence)}</div>
                        <div class="overview-decision-text">${esc(row.text)}</div>
                        <button class="overview-cta" data-overview-open-graph="${esc(agentName)}" data-overview-decision-index="${row.index}">Open in Causal Graph (level-3)</button>
                    </li>
                `).join('')}</ul>`
                : '<div>No decision entries available.</div>';

            return `
                <div class="overview-grid">
                    <div class="overview-detail"><h4>Agent snapshot</h4>${renderOverviewLines([
                        `Status: ${overview.status || 'unknown'}`,
                        `Task: ${overview.task || '—'}`,
                        `Last seen: ${overview.last_seen || 'n/a'}`,
                        `Cron jobs: ${overview.cron_jobs ?? 0}`,
                        `Interrupted tasks: ${(overview.interrupted_tasks || []).length}`,
                    ])}</div>
                    <div class="overview-detail"><h4>Top decisions (actionable)</h4>${decisionHtml}</div>
                    <div class="overview-detail"><h4>Recent cron evidence</h4>${renderOverviewLines(cronLines)}</div>
                    <div class="overview-detail"><h4>Context roots</h4>${renderOverviewLines(rootLines)}</div>
                </div>
            `;
        }

        async function openOverviewGraphDecision(agentName, decisionIndexRaw) {
            const decisionIndex = Number(decisionIndexRaw);
            await openDrilldown(agentName);
            setTab('graph');

            const graphNodes = store.drilldown?.depth?.causal_graph?.nodes || [];
            let nodeId = Number.isFinite(decisionIndex) ? `decision:${decisionIndex}` : '';
            if (!nodeId || !graphNodes.some((row) => String(row.id) === String(nodeId))) {
                const fallback = graphNodes.find((row) => String(row.group || '') === 'decision');
                nodeId = fallback ? String(fallback.id || '') : '';
            }

            const traceRow = Number.isFinite(decisionIndex)
                ? (store.drilldown?.depth?.decision_trace || [])[decisionIndex]
                : null;
            store.overviewBacklink = {
                agent: agentName,
                decisionIndex: Number.isFinite(decisionIndex) ? decisionIndex : null,
                nodeId: nodeId || null,
                decisionText: traceRow?.decision || '',
                ts: traceRow?.ts || '',
            };

            if (nodeId) {
                await openNodeDetails(nodeId);
            }
            closeOverviewModal();
        }

        function clearOverviewBacklink() {
            store.overviewBacklink = null;
            scheduleRender({ drilldown: true, overview: true, refresh: true });
        }

        async function openBacklinkGraphNode() {
            const link = store.overviewBacklink;
            if (!link || !link.agent) return;
            if (!store.drilldown || store.drilldown.agent !== link.agent) {
                await openDrilldown(link.agent);
            }
            setTab('graph');
            if (link.nodeId) {
                await openNodeDetails(link.nodeId);
            }
        }

        function bindOverviewModalInteractions() {
            const content = document.getElementById('overview-content');
            if (!content || content.dataset.bound === '1') return;
            content.addEventListener('click', async (event) => {
                const agentBtn = event.target.closest('[data-overview-agent]');
                if (agentBtn) {
                    store.overviewSelectedAgent = agentBtn.getAttribute('data-overview-agent') || null;
                    scheduleRender({ overview: true, refresh: true });
                    return;
                }

                const loadBtn = event.target.closest('[data-overview-load-deep]');
                if (loadBtn) {
                    const agent = loadBtn.getAttribute('data-overview-load-deep') || '';
                    if (!agent) return;
                    try {
                        const response = await fetch(`/drilldown/${encodeURIComponent(agent)}`);
                        store.overviewDeepByAgent[agent] = response.ok ? await response.json() : { found: false };
                    } catch (error) {
                        console.error('overview drilldown error', error);
                        store.overviewDeepByAgent[agent] = { found: false };
                    }
                    scheduleRender({ overview: true, refresh: true });
                }

                const graphBtn = event.target.closest('[data-overview-open-graph]');
                if (graphBtn) {
                    const agent = graphBtn.getAttribute('data-overview-open-graph') || '';
                    const index = graphBtn.getAttribute('data-overview-decision-index') || '';
                    if (!agent) return;
                    await openOverviewGraphDecision(agent, index);
                }
            });
            content.dataset.bound = '1';
        }

        function renderOverviewDetail(metricKey) {
            const titleMap = {
                agents: 'Observed agents · Deep detail',
                cron: 'Active cron jobs · Deep detail',
                user_agent: 'User → agent interactions · Deep detail',
                agent_agent: 'Agent → agent interactions · Deep detail',
                interrupted: 'Non-ok/interrupted tasks · Deep detail',
            };

            const entries = buildOverviewEntries(metricKey);
            const chosen = store.overviewSelectedAgent && entries.some((row) => row.agent === store.overviewSelectedAgent)
                ? store.overviewSelectedAgent
                : (entries[0]?.agent || null);
            store.overviewSelectedAgent = chosen;

            if (!entries.length) {
                return {
                    title: titleMap[metricKey] || 'Overview detail',
                    html: '<div class="overview-detail"><h4>Detail</h4><div>No records available for this metric.</div></div>',
                };
            }

            const selectedRow = entries.find((row) => row.agent === chosen) || entries[0];
            const listHtml = entries.map((row) => {
                const active = row.agent === selectedRow.agent ? 'active' : '';
                return `
                    <button class="overview-agent-btn ${active}" data-overview-agent="${esc(row.agent)}">
                        <div>${agentBadge(row.agent, true)}</div>
                        <div class="overview-subline">${esc(row.lines.length)} evidence lines</div>
                    </button>
                `;
            }).join('');

            const selectedLines = selectedRow.lines || [];
            const suggestions = [
                'Open Why decisions tab to validate rationale.',
                'Inspect Cron timeline for execution evidence.',
                'Inspect SOUL/file derivation for constraints alignment.',
                'Use Causal Graph for root-to-outcome causality.',
            ];

            return {
                title: titleMap[metricKey] || 'Overview detail',
                html: `
                    <div class="overview-grid deep">
                        <div class="overview-detail">
                            <h4>Agents involved</h4>
                            <div class="overview-agent-list">${listHtml}</div>
                        </div>
                        <div class="overview-detail">
                            <div class="overview-deep-head">
                                <h4 style="margin:0;">Agent focus: ${agentBadge(selectedRow.agent, true)}</h4>
                                <button class="overview-cta" data-overview-load-deep="${esc(selectedRow.agent)}">Load level-2 drilldown</button>
                            </div>
                            <div class="overview-detail" style="margin-bottom:8px;"><h4>Metric evidence</h4>${renderOverviewLines(selectedLines.slice(0, 120))}</div>
                            <div class="overview-detail" style="margin-bottom:8px;"><h4>Strategic next checks</h4>${renderOverviewLines(suggestions)}</div>
                            ${renderOverviewAgentDeep(selectedRow.agent)}
                        </div>
                    </div>
                `,
            };
        }

        function openOverviewModal(metricKey) {
            const modal = document.getElementById('overview-modal');
            bindOverviewModalInteractions();
            store.overviewCurrent = metricKey;
            modal.classList.add('open');
            modal.setAttribute('aria-hidden', 'false');
            renderState.overviewSignature = '';
            scheduleRender({ overview: true, refresh: true });
        }

        async function openDocsModal(targetDoc = null, targetAnchor = null) {
            const modal = document.getElementById('docs-modal');
            const title = document.getElementById('docs-title');
            const content = document.getElementById('docs-content');
            modal.classList.add('open');
            modal.setAttribute('aria-hidden', 'false');

            try {
                if (!store.docsIndex.length) {
                    await loadDocsIndex();
                }
                await buildDocsCatalog();

                const rows = store.docsCatalog;
                if (!rows.length) {
                    title.textContent = 'Documentation';
                    content.textContent = 'No docs available.';
                    return;
                }

                const defaultDoc = rows[0].doc;
                const docToOpen = targetDoc || store.docsCurrent || defaultDoc;
                const payload = await fetchDocContent(docToOpen);
                if (!payload || !payload.found) {
                    title.textContent = 'Documentation';
                    content.textContent = `Unable to load ${docToOpen}.`;
                    return;
                }

                store.docsCurrent = payload.doc || docToOpen;
                store.docsCurrentAnchor = targetAnchor || null;

                const currentCatalog = rows.find((item) => String(item.doc || '') === String(store.docsCurrent || ''));
                title.textContent = currentCatalog?.title || 'Documentation';

                content.innerHTML = markdownToHtml(payload.content || '');
                enhanceDocHeadings(content, store.docsCurrent);
                highlightCodeBlocks(content);

                if (store.docsCurrentAnchor) {
                    const anchorNode = document.getElementById(store.docsCurrentAnchor);
                    if (anchorNode) {
                        anchorNode.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                } else {
                    content.scrollTop = 0;
                }
                renderDocsMenu();
            } catch (error) {
                console.error('open docs modal error', error);
                title.textContent = 'Documentation';
                content.textContent = 'Unable to load documentation right now. Retry in a moment.';
            }
        }

        function isBenignDrilldownAbort(error, controller) {
            if (controller?.signal?.aborted) return true;
            const name = String(error?.name || '');
            if (name === 'AbortError') return true;
            const message = String(error?.message || '').toLowerCase();
            return message.includes('aborted');
        }

        function isBenignDrilldownNetworkError(error) {
            const name = String(error?.name || '').toLowerCase();
            const message = String(error?.message || '').toLowerCase();
            if (name === 'typeerror' && (message.includes('load failed') || message.includes('failed to fetch') || message.includes('networkerror'))) {
                return true;
            }
            return false;
        }

        async function openDrilldown(agentName, options = {}) {
            const background = Boolean(options.background);
            store.selectedAgent = agentName;
            store.nodeDetails = null;
            store.graphJump = null;
            store.graphNodeWeights = { graph: {}, graphfs: {} };
            const selectedBefore = store.drilldown?.agent || '';
            const cacheEntry = store.drilldownByAgent.get(agentName);
            const hasFreshCache = Boolean(cacheEntry && (Date.now() - Number(cacheEntry.ts || 0)) <= store.drilldownCacheTtlMs);

            if (hasFreshCache) {
                store.drilldown = cacheEntry.payload;
            }

            store.drilldownLoadingAgent = background ? null : agentName;
            scheduleRender({ agents: true, drilldown: true, refresh: true });

            if (store.drilldownAbortController) {
                try {
                    store.drilldownAbortController.abort();
                } catch (error) {
                }
            }

            const requestSeq = (store.drilldownRequestSeq || 0) + 1;
            store.drilldownRequestSeq = requestSeq;
            const controller = new AbortController();
            store.drilldownAbortController = controller;
            try {
                const response = await fetch(`/drilldown/${encodeURIComponent(agentName)}`, { signal: controller.signal });
                if (requestSeq !== store.drilldownRequestSeq) return;
                if (!response.ok) {
                    if (!hasFreshCache) store.drilldown = null;
                    store.drilldownLoadingAgent = null;
                    scheduleRender({ drilldown: true, refresh: true });
                    return;
                }
                const payload = await response.json();
                if (requestSeq !== store.drilldownRequestSeq) return;
                store.drilldown = payload;
                store.drilldownByAgent.set(agentName, { payload, ts: Date.now() });
                store.drilldownLoadingAgent = null;
                scheduleRender({ drilldown: true, refresh: true });
            } catch (error) {
                if (requestSeq !== store.drilldownRequestSeq) return;
                if (isBenignDrilldownAbort(error, controller)) return;
                if (background && isBenignDrilldownNetworkError(error)) return;
                console.error('drilldown error', error);
                if (!hasFreshCache && selectedBefore !== agentName) {
                    store.drilldown = null;
                }
                store.drilldownLoadingAgent = null;
                scheduleRender({ agents: true, drilldown: true, refresh: true });
            } finally {
                if (store.drilldownAbortController === controller) {
                    store.drilldownAbortController = null;
                }
            }
        }

        async function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) return;
            try {
                await navigator.serviceWorker.register('/sw.js', { scope: '/' });
            } catch (error) {
                console.warn('service worker registration failed', error);
            }
        }
        window.openDrilldown = openDrilldown;

        function renderAgentCardBody(item, loading = false) {
            const missions = Array.isArray(item.active_missions) && item.active_missions.length ? item.active_missions.join(', ') : '—';
            const interrupted = Array.isArray(item.interrupted_tasks) ? item.interrupted_tasks.length : 0;
            const key = safeDomKey(item.agent);
            const tokVal = parseTokenCount(item);
            const freshness = getAgentFreshness(item);
            return `
                <div class="agent-main">
                    <div class="agent-top">
                        ${agentBadge(item.agent)}
                    </div>
                    <div class="kv"><span class="muted">Status:</span> <span class="${statusClass(item.status)}">${esc(item.status || 'unknown')}</span></div>
                    <div class="kv"><span class="muted">Task:</span> ${esc(item.task || '—')}</div>
                    <div class="kv"><span class="muted">Cron:</span> ${esc(item.cron_jobs ?? 0)} ${interrupted ? `<span class="chip bad">${interrupted} non-ok</span>` : ''}</div>
                    <div class="kv"><span class="muted">Missions:</span> ${esc(missions)}</div>
                    <div class="kv"><span class="muted">Last event:</span> ${esc(item.last_seen || '—')}</div>
                    <div class="agent-click-hint">Open investigation <span aria-hidden="true">→</span></div>
                </div>
                <div class="agent-side">
                    ${loading ? '<span class="chip warn">loading…</span>' : ''}
                    <span class="chip live-indicator ${freshness.className}" title="${esc(freshness.title)}">${esc(freshness.label)}</span>
                    <div class="token-mini-widget">
                        <div class="token-mini-head">
                            <span class="token-mini-label">Tok</span>
                            <button class="help-btn micro" data-doc="03-ui-ux-guide.md" data-doc-anchor="03-ui-ux-guide.md-token-mini-chart-openclaw" title="How token metric works in OpenClaw">?</button>
                        </div>
                        <canvas class="token-mini-canvas" id="mini-tok-${esc(key)}" width="92" height="64"></canvas>
                        <div class="token-mini-value">${formatTokenCompact(tokVal)}</div>
                    </div>
                </div>
            `;
        }

        class OpenClawAgentCard extends HTMLElement {
            constructor() {
                super();
                this._item = null;
                this._selected = false;
                this._loading = false;
                this._bound = false;
            }

            connectedCallback() {
                if (!this._bound) {
                    this.setAttribute('role', 'button');
                    this.setAttribute('tabindex', '0');
                    this.addEventListener('click', (event) => {
                        const docBtn = event.target.closest('[data-doc]');
                        if (docBtn) {
                            event.stopPropagation();
                            openDocsModal(docBtn.dataset.doc || 'INDEX.md', docBtn.dataset.docAnchor || null);
                            return;
                        }
                        const agent = this._item?.agent || this.getAttribute('data-agent-name') || '';
                        if (agent) openDrilldown(agent);
                    });
                    this.addEventListener('keydown', (event) => {
                        if (event.key !== 'Enter' && event.key !== ' ') return;
                        event.preventDefault();
                        const agent = this._item?.agent || this.getAttribute('data-agent-name') || '';
                        if (agent) openDrilldown(agent);
                    });
                    this._bound = true;
                }
                this.render();
            }

            set item(value) {
                this._item = value || null;
                this.render();
            }

            set selected(value) {
                this._selected = Boolean(value);
                this.render();
            }

            get selected() {
                return this._selected;
            }

            set loading(value) {
                this._loading = Boolean(value);
                this.render();
            }

            get loading() {
                return this._loading;
            }

            render() {
                if (!this._item) return;
                this.className = `agent-card ${this._selected ? 'selected' : ''} ${this._loading ? 'loading' : ''}`;
                this.setAttribute('data-agent-key', safeDomKey(this._item.agent));
                this.setAttribute('data-agent-name', String(this._item.agent || ''));
                this.innerHTML = renderAgentCardBody(this._item, this._loading);
                markContentUpdate(this);
            }
        }

        if (!customElements.get('openclaw-agent-card')) {
            customElements.define('openclaw-agent-card', OpenClawAgentCard);
        }

        function rowSignature(item) {
            const interrupted = Array.isArray(item?.interrupted_tasks) ? item.interrupted_tasks.length : 0;
            const tokVal = parseTokenCount(item);
            const selected = String(store.selectedAgent || '') === String(item?.agent || '');
            const freshness = getAgentFreshness(item);
            return [
                item?.agent || '',
                item?.status || '',
                item?.task || '',
                item?.cron_jobs ?? 0,
                interrupted,
                item?.last_seen || '',
                formatTokenCompact(tokVal),
                freshness.bucket,
                selected ? 1 : 0,
            ].join('|');
        }

        function renderAgents() {
            const grid = document.getElementById('agent-grid');
            const rows = Array.from(store.agents.values()).sort((a, b) => String(a.agent).localeCompare(String(b.agent)));

            if (!rows.length) {
                grid.innerHTML = '<div class="row">Waiting for agent data...</div>';
                renderState.agentSignatures.clear();
                renderTelemetryCheck(rows);
                setKpiValue('agents', 0);
                return;
            }

            const existing = new Map();
            grid.querySelectorAll('openclaw-agent-card[data-agent-key]').forEach((node) => {
                existing.set(String(node.getAttribute('data-agent-key') || ''), node);
            });

            const nextKeys = new Set();
            const fragment = document.createDocumentFragment();
            rows.forEach((item) => {
                const key = safeDomKey(item.agent);
                const signature = rowSignature(item);
                const prevSignature = renderState.agentSignatures.get(key);
                let node = existing.get(key);
                const selected = String(store.selectedAgent || '') === String(item.agent || '');
                const loading = selected && String(store.drilldownLoadingAgent || '') === String(item.agent || '');

                if (!node || signature !== prevSignature) {
                    if (!node) node = document.createElement('openclaw-agent-card');
                    node.item = item;
                    node.selected = selected;
                    node.loading = loading;
                    renderState.agentSignatures.set(key, signature);
                } else if (node.selected !== selected || node.loading !== loading) {
                    node.selected = selected;
                    node.loading = loading;
                }
                if (node) fragment.appendChild(node);
                nextKeys.add(key);
            });

            Array.from(renderState.agentSignatures.keys()).forEach((key) => {
                if (!nextKeys.has(key)) renderState.agentSignatures.delete(key);
            });
            grid.replaceChildren(fragment);

            if (rows.length) renderAgentTelemetryCharts(rows);
            renderTelemetryCheck(rows);
            setKpiValue('agents', rows.length);
            const hint = document.getElementById('selection-hint');
            if (!store.selectedAgent) {
                hint.classList.remove('hidden');
                hint.textContent = '1) Select an agent to unlock deep investigation and causal graph analysis.';
            } else {
                hint.textContent = '';
                hint.classList.add('hidden');
            }
        }

        function renderInteractions() {
            const ua = (store.insights?.interactions?.user_agent || []).slice(0, 100);
            const aa = (store.insights?.interactions?.agent_agent || []).slice(0, 100);

            const signature = [
                ua.length,
                aa.length,
                ua[0]?.id || ua[0]?.ts || ua[0]?.text || '',
                aa[0]?.id || aa[0]?.ts || aa[0]?.text || '',
            ].join('|');
            if (signature === renderState.interactionsSignature) return;
            renderState.interactionsSignature = signature;

            setKpiValue('ua', ua.length);
            setKpiValue('aa', aa.length);

            const uaList = document.getElementById('user-agent-list');
            const aaList = document.getElementById('agent-agent-list');
            if (uaList && typeof uaList.setRows === 'function') uaList.setRows(ua);
            if (aaList && typeof aaList.setRows === 'function') aaList.setRows(aa);
        }

        function renderDrilldown() {
            const title = document.getElementById('drill-title');
            const body = document.getElementById('drill-body');
            const selectedLabel = document.getElementById('selected-agent-label');
            const breadcrumb = document.getElementById('investigation-breadcrumb');
            const payload = store.drilldown;
            const loading = Boolean(store.drilldownLoadingAgent && String(store.selectedAgent || '') === String(store.drilldownLoadingAgent || ''));

            const depth = payload?.depth || {};
            const signature = [
                store.activeTab,
                payload?.found ? 1 : 0,
                payload?.agent || '',
                (depth?.decision_trace || []).length,
                (depth?.timeline || []).length,
                (depth?.cron_timeline || []).length,
                (depth?.context_roots || []).length,
                (depth?.causal_graph?.nodes || []).length,
                (depth?.causal_graph?.edges || []).length,
                store.nodeDetails?.node?.id || '',
                store.overviewBacklink?.agent || '',
                store.overviewBacklink?.decisionIndex ?? '',
            ].join('|');
            if (signature === renderState.drilldownSignature) return;
            renderState.drilldownSignature = signature;

            const tabLabels = {
                decisions: 'Why decisions',
                soul: 'SOUL/file derivation',
                graph: 'Causal Graph',
                cron_timeline: 'Cron timeline',
                timeline: 'Full timeline',
                overview: 'Overview',
            };

            if (loading && (!payload || String(payload.agent || '') !== String(store.selectedAgent || ''))) {
                const target = store.selectedAgent || 'agent';
                title.textContent = `Deep investigation (${target})`;
                selectedLabel.innerHTML = `Current agent: ${agentBadge(target, true)}`;
                if (breadcrumb) {
                    breadcrumb.innerHTML = `Path: ${renderBreadcrumbCrumb({ label: 'Swarm', action: 'swarm', strong: true }, false)}<span class="sep">›</span>${renderBreadcrumbCrumb({ label: String(target), action: 'agent', value: String(target), strong: true }, true)}`;
                }
                body.innerHTML = '<div class="trace-item">Loading drilldown content…</div>';
                return;
            }

            if (!payload || !payload.found) {
                title.textContent = 'Deep investigation (select an agent)';
                selectedLabel.textContent = 'Current agent: none';
                if (breadcrumb) {
                    breadcrumb.innerHTML = `Path: ${renderBreadcrumbCrumb({ label: 'Swarm', action: 'swarm', strong: true }, true)}`;
                }
                body.innerHTML = 'No agent selected yet.';
                return;
            }

            title.textContent = `Investigation ${payload.agent} · ${store.activeTab}`;
            selectedLabel.innerHTML = `Current agent: ${agentBadge(payload.agent, true)}`;

            const crumbs = [
                { label: 'Swarm', action: 'swarm', strong: true },
                { label: String(payload.agent || 'unknown'), action: 'agent', value: String(payload.agent || ''), strong: true },
                { label: tabLabels[store.activeTab] || store.activeTab || 'decisions', action: 'tab', value: store.activeTab },
            ];
            if (store.overviewBacklink && String(store.overviewBacklink.agent || '') === String(payload.agent || '')) {
                crumbs.push({ label: 'Overview link', action: 'overview-link' });
                if (Number.isFinite(store.overviewBacklink.decisionIndex)) {
                    crumbs.push({ label: `Decision #${String(store.overviewBacklink.decisionIndex)}`, action: 'decision' });
                }
            }
            if (store.activeTab === 'graph' && store.nodeDetails?.node?.id) {
                crumbs.push({ label: `Node ${String(store.nodeDetails.node.id)}`, action: 'node', value: String(store.nodeDetails.node.id) });
            }
            if (breadcrumb) {
                const currentTabAction = 'tab';
                const currentTabValue = store.activeTab;
                const rendered = crumbs.map((crumb) => {
                    const isActive = crumb?.action === currentTabAction && String(crumb?.value || '') === String(currentTabValue || '');
                    return renderBreadcrumbCrumb(crumb, isActive);
                });
                breadcrumb.innerHTML = `Path: ${rendered.join('<span class="sep">›</span>')}`;
            }

            if (store.activeTab === 'overview') {
                const o = depth.overview || {};
                body.innerHTML = `
                    <div class="trace-item"><span class="pill">Status</span>${esc(o.status || 'unknown')}</div>
                    <div class="trace-item"><span class="pill">Task</span>${esc(o.task || '—')}</div>
                    <div class="trace-item"><span class="pill">Last Seen</span>${esc(o.last_seen || '—')}</div>
                    <div class="trace-item"><span class="pill">Cron Jobs</span>${esc(o.cron_jobs ?? 0)}</div>
                    <div class="trace-item"><span class="pill">Interrupted</span>${esc((o.interrupted_tasks || []).length)}</div>
                `;
                return;
            }

            if (store.activeTab === 'timeline') {
                const rows = (depth.timeline || []).slice(0, 120);
                body.innerHTML = rows.length ? rows.map((row) => `
                    <div class="trace-item">
                        <div><span class="pill">${esc(row.source || 'source')}</span><span class="pill">${esc(row.type || 'type')}</span></div>
                        <div>${esc(row.text || '')}</div>
                        <div class="when">${esc(row.ts || '')}</div>
                    </div>
                `).join('') : 'Timeline not available.';
                return;
            }

            if (store.activeTab === 'cron_timeline') {
                const allRows = depth.cron_timeline || [];
                const start = Math.max(0, allRows.length - 120);
                const rows = allRows.slice(start);
                const graphJump = store.graphJump;
                body.innerHTML = rows.length ? rows.map((row, idx) => {
                    const absoluteIndex = start + idx;
                    const linked = graphJump && graphJump.tab === 'cron_timeline' && Number(graphJump.actionIndex) === Number(absoluteIndex) ? 'linked' : '';
                    const jumpMark = linked ? 'data-graph-jump-target="1"' : '';
                    return `
                    <div class="trace-item ${linked}" ${jumpMark}>
                        <div><span class="pill">${esc(row.kind || 'event')}</span><span class="pill">${esc(row.job || 'cron')}</span><span class="pill ${statusClass(row.status)}">${esc(row.status || '')}</span></div>
                        <div>${esc(row.summary || '—')}</div>
                        <div class="small">${row.in_seconds != null ? `in ${esc(row.in_seconds)}s` : ''} ${row.duration_ms ? `· duration ${esc(row.duration_ms)}ms` : ''}</div>
                        <div class="when">${esc(row.ts || '')}</div>
                    </div>
                `;
                }).join('') : 'No cron timeline available.';
                focusGraphJumpTarget(body);
                return;
            }

            if (store.activeTab === 'soul') {
                const roots = (depth.context_roots || []).slice(0, 20);
                const graphJump = store.graphJump;
                body.innerHTML = roots.length ? roots.map((row, idx) => {
                    const linked = graphJump && graphJump.tab === 'soul' && Number(graphJump.rootIndex) === Number(idx) ? 'linked' : '';
                    const jumpMark = linked ? 'data-graph-jump-target="1"' : '';
                    return `
                    <div class="trace-item ${linked}" ${jumpMark}>
                        <div><span class="pill">root file</span>${esc(row.file || '')}</div>
                        <div class="small"><strong>Anchor matches:</strong> ${esc((row.matched_anchors || []).join(' · ') || 'none')}</div>
                        <div class="small muted">${esc((row.anchors || []).slice(0, 6).join(' | '))}</div>
                    </div>
                `;
                }).join('') : 'No context files available for this agent.';
                focusGraphJumpTarget(body);
                return;
            }

            if (store.activeTab === 'graph') {
                body.innerHTML = renderCausalGraph(depth.causal_graph || { nodes: [], edges: [] }, { prefix: 'graph', expandable: true });
                initGraphViewport('graph');
                const expandBtn = document.getElementById('graph-expand-btn');
                if (expandBtn) {
                    expandBtn.addEventListener('click', openGraphFullscreenModal);
                }
                return;
            }

            const rowsRaw = (depth.decision_trace || []).slice(0, 80);
            const rowsSorted = rowsRaw
                .map((row, originalIndex) => ({
                    row,
                    originalIndex,
                    tsMs: parseTimestampMs(row?.ts),
                }))
                .sort((a, b) => {
                    const aTs = Number.isFinite(a.tsMs) ? a.tsMs : -Infinity;
                    const bTs = Number.isFinite(b.tsMs) ? b.tsMs : -Infinity;
                    if (aTs !== bTs) return bTs - aTs;
                    return a.originalIndex - b.originalIndex;
                });

            const rows = [];
            for (const entry of rowsSorted) {
                const row = entry.row || {};
                const signature = [
                    String(row.decision || '').replace(/\s+/g, ' ').trim(),
                    normalizeTextList(row.why || []).join('|'),
                    normalizeTextList(row.evidence || []).join('|'),
                    formatRootCauseItems(row.root_causes).join('|'),
                ].join('||');

                const last = rows[rows.length - 1];
                if (last && last.signature === signature) {
                    last.repeatCount += 1;
                    continue;
                }

                rows.push({
                    ...entry,
                    signature,
                    repeatCount: 1,
                });
            }

            const backlink = store.overviewBacklink;
            const showBacklink = backlink && String(backlink.agent || '') === String(payload.agent || '');
            const banner = showBacklink ? `
                <div class="backlink-banner">
                    <div><strong>Backlink:</strong> opened from overview level-3 · decision ${esc((backlink.decisionIndex ?? '-') + '')} ${backlink.decisionText ? `· ${esc(backlink.decisionText)}` : ''}</div>
                    <div style="display:flex;gap:6px;">
                        <button class="overview-cta" id="open-backlink-graph">Open linked graph node</button>
                        <button class="overview-cta" id="clear-backlink">Clear link</button>
                    </div>
                </div>
            ` : '';
            body.innerHTML = rows.length ? `${banner}<div class="decision-order-hint">Timeline order: newest → oldest.</div>${rows.map((entry, idx) => {
                const row = entry.row || {};
                const graphJump = store.graphJump;
                const linkedGraph = graphJump && graphJump.tab === 'decisions' && Number(graphJump.decisionIndex) === Number(entry.originalIndex);
                const linkedOverview = showBacklink && Number(backlink.decisionIndex) === Number(entry.originalIndex);
                const linked = (linkedOverview || linkedGraph) ? 'linked' : '';
                const jumpMark = linkedGraph ? 'data-graph-jump-target="1"' : '';
                const alt = (idx % 2 === 1) ? 'alt' : '';
                const ts = formatDecisionTime(row.ts, entry.tsMs);
                const whyBlock = renderCollapsibleTraceList('Why', row.why || [], { previewLimit: 2, open: linked });
                const evidenceBlock = renderCollapsibleTraceList('Runtime evidence', row.evidence || [], { previewLimit: 2 });
                const rootCauseBlock = renderCollapsibleTraceList('Root causes (SOUL/files)', formatRootCauseItems(row.root_causes), { previewLimit: 1 });
                const reasoningBlock = renderHumanReasoning(row);
                return `
                <div class="trace-item decision-item ${alt} ${linked}" ${jumpMark}>
                    <div class="decision-timeline-head">
                        <div class="decision-meta-left">
                            <span class="pill">confidence ${esc(row.confidence || 'n/a')}</span>
                            <span class="pill">${esc(row.source || '')}</span>
                            ${entry.repeatCount > 1 ? `<span class="pill">repeated ×${esc(String(entry.repeatCount))}</span>` : ''}
                        </div>
                        <div class="decision-time-box">
                            <div class="decision-time-strong">${esc(ts.strong)}</div>
                        </div>
                    </div>
                    <div class="decision-line"><strong>Decision:</strong> ${esc(row.decision || '')}</div>
                    <details class="decision-logic" ${linked ? 'open' : ''}>
                        <summary class="decision-logic-toggle" aria-label="Expand logic" title="Expand logic">
                            <span class="logic-toggle-icon" aria-hidden="true"></span>
                        </summary>
                        <div class="decision-logic-body">
                            ${reasoningBlock}
                            ${whyBlock}
                            ${evidenceBlock}
                            ${rootCauseBlock}
                        </div>
                    </details>
                </div>
                `;
            }).join('')}` : 'Decision trace not available.';

            if (showBacklink) {
                const openBtn = document.getElementById('open-backlink-graph');
                const clearBtn = document.getElementById('clear-backlink');
                if (openBtn) openBtn.addEventListener('click', openBacklinkGraphNode);
                if (clearBtn) clearBtn.addEventListener('click', clearOverviewBacklink);
            }
            focusGraphJumpTarget(body);
        }

        function focusGraphJumpTarget(container) {
            if (!container) return;
            const target = container.querySelector('[data-graph-jump-target="1"]');
            if (!target) return;
            requestAnimationFrame(() => {
                target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                target.classList.add('jump-target');
                setTimeout(() => target.classList.remove('jump-target'), 3400);
            });
        }

        function groupColor(group) {
            const map = {
                agent: '#6ea8ff',
                root: '#f59e0b',
                reason: '#38bdf8',
                signal: '#f97316',
                decision: '#16c784',
                action: '#c084fc',
                outcome_ok: '#22c55e',
                outcome_bad: '#ef4444',
            };
            return map[group] || '#64748b';
        }

        function summarizeGraphMeta(meta = {}) {
            const lines = [];
            if (meta.ts) lines.push(`Time: ${meta.ts}`);
            if (meta.status) lines.push(`Status: ${meta.status}`);
            if (meta.confidence) lines.push(`Confidence: ${meta.confidence}`);
            if (meta.job) lines.push(`Job: ${meta.job}`);
            if (meta.file) lines.push(`File: ${meta.file}`);
            if (meta.task) lines.push(`Task: ${meta.task}`);
            if (Array.isArray(meta.anchors) && meta.anchors.length) lines.push(`Anchors: ${meta.anchors.slice(0, 4).join(' · ')}`);
            return lines;
        }

        function deriveGraphJump(node) {
            const group = String(node?.group || '');
            const meta = (node && typeof node.meta === 'object' && node.meta) ? node.meta : {};
            const jumpTab = String(meta.jump_tab || '').trim();

            if (jumpTab === 'decisions' || group === 'decision' || group === 'reason' || group === 'signal') {
                return {
                    tab: 'decisions',
                    decisionIndex: Number.isFinite(Number(meta.decision_index)) ? Number(meta.decision_index) : null,
                };
            }
            if (jumpTab === 'cron_timeline' || group === 'action' || group === 'outcome_ok' || group === 'outcome_bad') {
                return {
                    tab: 'cron_timeline',
                    actionIndex: Number.isFinite(Number(meta.action_index)) ? Number(meta.action_index) : null,
                };
            }
            if (jumpTab === 'soul' || group === 'root') {
                return {
                    tab: 'soul',
                    rootIndex: Number.isFinite(Number(meta.root_index)) ? Number(meta.root_index) : null,
                };
            }
            return { tab: 'graph' };
        }

        function splitGraphLabel(value, maxCharsPerLine = 24, maxLines = 2) {
            const text = String(value || '').replace(/\s+/g, ' ').trim();
            if (!text) return [''];
            const words = text.split(' ');
            const lines = [];
            let current = '';

            for (const word of words) {
                let token = word;
                while (token.length > maxCharsPerLine) {
                    const chunk = token.slice(0, maxCharsPerLine - 1) + '…';
                    if (current) {
                        lines.push(current);
                        current = '';
                    }
                    lines.push(chunk);
                    token = token.slice(maxCharsPerLine - 1);
                    if (lines.length >= maxLines) return lines.slice(0, maxLines);
                }

                const candidate = current ? `${current} ${token}` : token;
                if (candidate.length <= maxCharsPerLine) {
                    current = candidate;
                } else {
                    if (current) lines.push(current);
                    current = token;
                }
                if (lines.length >= maxLines) return lines.slice(0, maxLines);
            }

            if (current && lines.length < maxLines) lines.push(current);
            const joined = lines.join(' ');
            if (joined.length < text.length && lines.length) {
                const last = lines[lines.length - 1];
                if (!last.endsWith('…')) lines[lines.length - 1] = `${last.slice(0, Math.max(last.length - 1, 0))}…`;
            }
            return lines;
        }

        function renderCausalGraph(graph, options = {}) {
            const nodes = Array.isArray(graph.nodes) ? graph.nodes : [];
            const edges = Array.isArray(graph.edges) ? graph.edges : [];
            if (!nodes.length) {
                return '<div class="trace-item">Graph is not available for this agent.</div>';
            }

            const prefix = String(options.prefix || 'graph');
            const expandable = Boolean(options.expandable);
            const stageId = `${prefix}-stage`;
            const svgId = `${prefix}-svg`;
            const layerId = `${prefix}-layer`;
            const arrowId = `${prefix}-arrow`;
            const selectedNodeId = String(store.nodeDetails?.node?.id || '');
            const previousWeights = store.graphNodeWeights[prefix] || {};
            const nextWeights = {};
            const triggerNodeIds = new Set(
                nodes
                    .filter((node) => Boolean(node?.meta?.trigger_source))
                    .map((node) => String(node?.id || ''))
            );

            const nodeWeight = (node) => {
                const raw = Number(node?.meta?.weight);
                if (Number.isFinite(raw)) return Math.max(0.1, Math.min(1.9, raw));
                return 0.45;
            };
            const edgeWeight = (edge) => {
                const raw = Number(edge?.meta?.weight);
                if (Number.isFinite(raw)) return Math.max(0.1, Math.min(1.9, raw));
                return 0.45;
            };

            const layers = { root: [], reason: [], signal: [], agent: [], decision: [], action: [], outcome_ok: [], outcome_bad: [], other: [] };
            nodes.forEach((node) => {
                const g = String(node.group || 'other');
                if (layers[g]) layers[g].push(node);
                else layers.other.push(node);
            });
            Object.values(layers).forEach((bucket) => {
                bucket.sort((a, b) => {
                    const wa = nodeWeight(a);
                    const wb = nodeWeight(b);
                    if (wa !== wb) return wb - wa;
                    const ta = Number(parseTimestampMs(a?.meta?.ts || '')) || 0;
                    const tb = Number(parseTimestampMs(b?.meta?.ts || '')) || 0;
                    if (ta !== tb) return tb - ta;
                    return String(a?.id || '').localeCompare(String(b?.id || ''));
                });
            });

            const columns = ['root', 'reason', 'signal', 'agent', 'decision', 'action', 'outcome_ok', 'outcome_bad', 'other'];
            const xStep = 232;
            const yStep = 92;
            const marginX = 40;
            const marginY = 26;
            const width = marginX * 2 + xStep * (columns.length - 1) + 230;
            const maxRows = Math.max(...columns.map((c) => layers[c].length), 1);
            const height = Math.max(420, marginY * 2 + yStep * maxRows + 120);

            const positioned = {};
            columns.forEach((col, colIndex) => {
                layers[col].forEach((node, rowIndex) => {
                    positioned[node.id] = { ...node, x: marginX + colIndex * xStep, y: marginY + rowIndex * yStep };
                });
            });

            const edgeSvg = edges.map((edge) => {
                const s = positioned[edge.source];
                const t = positioned[edge.target];
                if (!s || !t) return '';
                const x1 = s.x + 196;
                const y1 = s.y + 22;
                const x2 = t.x;
                const y2 = t.y + 22;
                const mx = (x1 + x2) / 2;
                const my = (y1 + y2) / 2;
                const edgeLabel = String(edge.label || '');
                const edgeShort = splitGraphLabel(edgeLabel, 16, 1)[0] || '';
                const isLive = Boolean(edge?.meta?.live);
                const isSelected = selectedNodeId && (String(edge.source || '') === selectedNodeId || String(edge.target || '') === selectedNodeId);
                const isTriggerFlow = triggerNodeIds.has(String(edge.source || '')) || triggerNodeIds.has(String(edge.target || ''));
                const edgeClass = `graph-edge ${isLive ? 'live' : ''} ${isSelected ? 'selected' : ''} ${isTriggerFlow ? 'trigger-flow' : ''}`;
                const strokeWidth = (1 + (edgeWeight(edge) * 0.9)).toFixed(2);
                return `
                    <g class="${edgeClass}">
                        <line class="graph-edge-line" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#45608f" stroke-width="${strokeWidth}" marker-end="url(#${arrowId})" />
                    </g>
                    <text x="${mx}" y="${my - 4}" class="graph-edge-text">${esc(edgeShort)}</text>
                    <title>${esc(edgeLabel)}</title>
                `;
            }).join('');

            const nodeSvg = Object.values(positioned).map((node) => {
                const fill = groupColor(node.group);
                const fullLabel = String(node.label || '');
                const lines = splitGraphLabel(fullLabel, 24, 2);
                const weight = nodeWeight(node);
                const prevWeight = Number(previousWeights[node.id]);
                const weightDelta = Number.isFinite(prevWeight) ? (weight - prevWeight) : 0;
                nextWeights[node.id] = weight;
                const isLive = Boolean(node?.meta?.live);
                const isTriggerSource = Boolean(node?.meta?.trigger_source);
                const isSelected = selectedNodeId && String(node.id || '') === selectedNodeId;
                const isImpact = isTriggerSource || isSelected || isLive;
                const nodeClass = `graph-node ${isLive ? 'live' : ''} ${isSelected ? 'selected' : ''} ${isTriggerSource ? 'trigger-source' : ''} ${isImpact ? 'impact' : ''} ${weightDelta > 0.03 ? 'weight-up' : ''} ${weightDelta < -0.03 ? 'weight-down' : ''}`;
                const nodeStrokeWidth = (1.25 + (weight * 0.7)).toFixed(2);
                const weightLabel = `w:${weight.toFixed(2)}`;
                return `
                    <g class="${nodeClass}" data-node-id="${esc(node.id)}" style="cursor:pointer;">
                        <rect class="graph-node-rect" x="${node.x}" y="${node.y}" width="196" height="54" rx="8" ry="8" fill="#16213d" stroke="${fill}" stroke-width="${nodeStrokeWidth}"></rect>
                        <text x="${node.x + 8}" y="${node.y + 17}" class="graph-node-text">${esc(lines[0] || '')}</text>
                        <text x="${node.x + 8}" y="${node.y + 30}" class="graph-node-text">${esc(lines[1] || '')}</text>
                        <text x="${node.x + 8}" y="${node.y + 46}" class="graph-edge-text">${esc(`${node.group || ''} · ${weightLabel}`)}</text>
                        <title>${esc(fullLabel)}</title>
                    </g>
                `;
            }).join('');
            store.graphNodeWeights[prefix] = nextWeights;

            const detail = store.nodeDetails;
            const detailMeta = detail?.node?.meta && typeof detail.node.meta === 'object' ? detail.node.meta : {};
            const metaSummary = summarizeGraphMeta(detailMeta);
            const detailHtml = detail ? `
                <div class="trace-item">
                    <div><span class="pill">Node</span>${esc(detail.node?.id || '')}</div>
                    <div><strong>${esc(detail.node?.label || '')}</strong></div>
                    ${metaSummary.length ? `<div class="small muted">${metaSummary.map((line) => esc(line)).join('<br>')}</div>` : ''}
                    <div class="small"><strong>Inbound:</strong> ${esc((detail.inbound_edges || []).map(e => `${e.source}→${e.target}`).join(' | ') || '—')}</div>
                    <div class="small"><strong>Outbound:</strong> ${esc((detail.outbound_edges || []).map(e => `${e.source}→${e.target}`).join(' | ') || '—')}</div>
                    ${detail.file_detail ? `<div class="small muted"><strong>File:</strong> ${esc(detail.file_detail.file || '')}<br><strong>Anchors:</strong> ${esc((detail.file_detail.matched_anchors || []).join(' · ') || '—')}</div>` : ''}
                </div>
            ` : '<div class="trace-item">Click a graph node to inspect deeper details (metadata, relations, source file).</div>';

            const legend = [
                ['root', 'Context roots'],
                ['reason', 'Why'],
                ['signal', 'Runtime evidence'],
                ['decision', 'Decision'],
                ['action', 'Action'],
                ['outcome_ok', 'Positive outcome'],
                ['outcome_bad', 'Negative outcome'],
            ].map(([group, label]) => `<span class="graph-legend-item"><span class="graph-legend-dot" style="background:${groupColor(group)}"></span>${esc(label)}</span>`).join('');
            const liveCount = nodes.filter((node) => node?.meta?.live).length;
            const avgWeight = nodes.length ? (nodes.reduce((sum, node) => sum + nodeWeight(node), 0) / nodes.length) : 0;

            return `
                <div class="graph-wrap">
                    <div class="graph-summary">
                        <div><strong>Causal path:</strong> context/reasons → decision → action → outcome</div>
                        <div class="small muted">Live nodes highlighted: ${esc(String(liveCount))} · average decision weight: ${esc(avgWeight.toFixed(2))} · click a node to open contextual drilldown.</div>
                        <div class="graph-legend">${legend}</div>
                    </div>
                    ${detailHtml}
                    ${expandable ? '<div class="graph-actions"><button id="graph-expand-btn" class="graph-expand-btn" title="Expand graph view">Expand</button></div>' : ''}
                    <div class="small muted" style="margin-bottom:6px;">Pan: drag · Zoom: wheel · Reset: double-click</div>
                    <div id="${stageId}" class="graph-stage">
                        <svg id="${svgId}" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <marker id="${arrowId}" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L8,4 L0,8 z" fill="#45608f" />
                                </marker>
                            </defs>
                            <g id="${layerId}">${edgeSvg}${nodeSvg}</g>
                        </svg>
                    </div>
                </div>
            `;
        }

        function getGraphViewport(prefix = 'graph') {
            return prefix === 'graphfs' ? store.graphViewportFullscreen : store.graphViewport;
        }

        function applyGraphTransform(prefix = 'graph') {
            const layer = document.getElementById(`${prefix}-layer`);
            if (!layer) return;
            const v = getGraphViewport(prefix);
            layer.setAttribute('transform', `translate(${v.tx} ${v.ty}) scale(${v.scale})`);
        }

        function shouldDeferDrilldownRefresh() {
            if (store.activeTab !== 'graph') return false;
            return (Date.now() - (store.graphInteractionTs || 0)) < 9000;
        }

        async function openNodeDetails(nodeId) {
            if (!store.selectedAgent) return;
            try {
                const response = await fetch(`/drilldown/${encodeURIComponent(store.selectedAgent)}/node/${encodeURIComponent(nodeId)}`);
                if (!response.ok) return;
                const payload = await response.json();
                store.nodeDetails = payload;
                const jump = deriveGraphJump(payload?.node || {});
                store.graphJump = jump;
                if (jump?.tab && jump.tab !== 'graph') {
                    setTab(jump.tab);
                    const modal = document.getElementById('graph-fullscreen-modal');
                    if (modal && modal.classList.contains('open')) closeGraphFullscreenModal();
                }
                scheduleRender({ drilldown: true, refresh: true });
            } catch (error) {
                console.error('node details error', error);
            }
        }

        function initGraphViewport(prefix = 'graph') {
            const stage = document.getElementById(`${prefix}-stage`);
            const layer = document.getElementById(`${prefix}-layer`);
            if (!stage || !layer) return;
            const viewport = getGraphViewport(prefix);
            applyGraphTransform(prefix);

            layer.querySelectorAll('.graph-node').forEach((node) => {
                node.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    store.graphInteractionTs = Date.now();
                    openNodeDetails(node.getAttribute('data-node-id'));
                });
            });

            let dragging = false;
            let lastX = 0;
            let lastY = 0;

            stage.onmousedown = (ev) => {
                dragging = true;
                stage.classList.add('dragging');
                lastX = ev.clientX;
                lastY = ev.clientY;
                store.graphInteractionTs = Date.now();
            };
            window.onmouseup = () => {
                dragging = false;
                stage.classList.remove('dragging');
            };
            window.onmousemove = (ev) => {
                if (!dragging) return;
                const dx = ev.clientX - lastX;
                const dy = ev.clientY - lastY;
                lastX = ev.clientX;
                lastY = ev.clientY;
                viewport.tx += dx;
                viewport.ty += dy;
                store.graphInteractionTs = Date.now();
                applyGraphTransform(prefix);
            };
            stage.onwheel = (ev) => {
                ev.preventDefault();
                const delta = ev.deltaY < 0 ? 1.08 : 0.92;
                viewport.scale = Math.max(0.25, Math.min(3.4, viewport.scale * delta));
                store.graphInteractionTs = Date.now();
                applyGraphTransform(prefix);
            };
            stage.ondblclick = () => {
                viewport.scale = 1;
                viewport.tx = 0;
                viewport.ty = 0;
                store.graphInteractionTs = Date.now();
                applyGraphTransform(prefix);
            };
        }

        function renderKpiCron() {
            const byAgent = store.insights?.cron?.by_agent || {};
            let interrupted = 0;
            Object.values(byAgent).forEach((jobs) => {
                (jobs || []).forEach((job) => {
                    if (job && job.interrupted) interrupted += 1;
                });
            });

            const signature = `${interrupted}|${store.insights?.cron?.summary?.active_jobs ?? 0}`;
            if (signature === renderState.kpiSignature) return;
            renderState.kpiSignature = signature;

            setKpiValue('bad', interrupted);
            setKpiValue('cron', store.insights?.cron?.summary?.active_jobs ?? 0);
        }

        function render() {
            scheduleRender({
                agents: true,
                interactions: true,
                kpi: true,
                drilldown: true,
                overview: true,
                refresh: true,
            });
        }

        function scheduleRender(partial = {}) {
            renderState.dirty = {
                ...renderState.dirty,
                ...partial,
            };
            if (renderState.queued) return;
            renderState.queued = true;
            requestAnimationFrame(flushRender);
        }

        function flushRender() {
            renderState.queued = false;
            const dirty = renderState.dirty;
            renderState.dirty = {
                agents: false,
                interactions: false,
                kpi: false,
                drilldown: false,
                overview: false,
                refresh: false,
            };

            if (dirty.agents) renderAgents();
            if (dirty.interactions) renderInteractions();
            if (dirty.kpi) renderKpiCron();
            if (dirty.drilldown) renderDrilldown();
            if (dirty.overview && store.overviewCurrent) {
                const modal = document.getElementById('overview-modal');
                if (modal && modal.classList.contains('open')) {
                    const detail = renderOverviewDetail(store.overviewCurrent);
                    const signature = [
                        store.overviewCurrent,
                        store.overviewSelectedAgent || '',
                        detail.title,
                        detail.html.length,
                    ].join('|');
                    if (signature !== renderState.overviewSignature) {
                        renderState.overviewSignature = signature;
                        document.getElementById('overview-title').textContent = detail.title;
                        document.getElementById('overview-content').innerHTML = detail.html;
                    }
                }
            }
            if (dirty.refresh) {
                document.getElementById('last-refresh').textContent = `sync ${new Date().toLocaleTimeString()}`;
            }
        }

        async function refreshInsights() {
            if (store.refreshInFlight) {
                store.refreshQueued = true;
                return;
            }
            store.refreshInFlight = true;
            const refreshBadge = document.getElementById('last-refresh');
            if (refreshBadge) {
                refreshBadge.dataset.state = 'running';
            }
            try {
                const response = await fetch('/insights');
                if (!response.ok) return;
                const payload = await response.json();
                store.insights = payload;

                const agents = Array.isArray(payload.agents) ? payload.agents : [];
                store.agents.clear();
                agents.forEach((agent) => {
                    if (agent && agent.agent) store.agents.set(agent.agent, agent);
                });

                const orderedAgentNames = Array.from(store.agents.keys()).sort((a, b) => String(a).localeCompare(String(b)));
                const selectedPresent = orderedAgentNames.some((name) => String(name) === String(store.selectedAgent || ''));

                if (!selectedPresent) {
                    store.selectedAgent = orderedAgentNames.length ? orderedAgentNames[0] : null;
                }
                if (store.selectedAgent && !shouldDeferDrilldownRefresh()) {
                    await openDrilldown(store.selectedAgent, { background: true });
                }
                scheduleRender({
                    agents: true,
                    interactions: true,
                    kpi: true,
                    drilldown: !store.selectedAgent,
                    overview: true,
                    refresh: true,
                });
            } catch (error) {
                console.error('insights error', error);
            } finally {
                store.refreshInFlight = false;
                if (refreshBadge) {
                    refreshBadge.dataset.state = 'idle';
                }
                if (store.refreshQueued) {
                    store.refreshQueued = false;
                    requestAnimationFrame(() => refreshInsights());
                }
            }
        }

        async function waitForReady(retries = 10, delay = 600) {
            for (let i = 0; i < retries; i += 1) {
                try {
                    const response = await fetch('/ready');
                    if (response.ok) {
                        const payload = await response.json();
                        if (payload && payload.ready) return true;
                    }
                } catch (error) {
                }
                await new Promise((resolve) => setTimeout(resolve, delay));
                delay = Math.min(2000, Math.floor(delay * 1.45));
            }
            return false;
        }

        function bindSocketHandlers(socket) {
            socket.on('init', (data) => {
                if (!Array.isArray(data)) return;
                data.forEach((row) => {
                    if (row && row.agent) store.agents.set(row.agent, row);
                });
                scheduleRender({ agents: true, refresh: true });
            });

            socket.on('update', (data) => {
                if (!data || !data.agent) return;
                store.agents.set(data.agent, data);
                if (store.selectedAgent && String(store.selectedAgent) === String(data.agent) && !shouldDeferDrilldownRefresh()) {
                    openDrilldown(store.selectedAgent, { background: true });
                }
                scheduleRender({ agents: true, refresh: true });
            });

            socket.on('init_pending', () => {
                setTimeout(() => socket.emit('init_request'), 1200);
            });
        }

        (async function bootstrap() {
            document.addEventListener('dragstart', (event) => {
                event.preventDefault();
            });
            const footerYear = document.getElementById('footer-year');
            if (footerYear) {
                footerYear.textContent = String(new Date().getFullYear());
            }
            registerServiceWorker();
            document.querySelectorAll('.tab').forEach((node) => {
                node.addEventListener('click', () => setTab(node.dataset.tab));
            });
            renderActiveTabHelp();
            document.getElementById('open-docs-index').addEventListener('click', () => openDocsModal('INDEX.md'));
            document.getElementById('close-docs').addEventListener('click', closeDocsModal);
            document.getElementById('close-overview').addEventListener('click', closeOverviewModal);
            document.getElementById('close-graph-fullscreen').addEventListener('click', closeGraphFullscreenModal);
            document.getElementById('close-telemetry-modal').addEventListener('click', closeTelemetryModal);
            document.getElementById('telemetry-warning-btn').addEventListener('click', openTelemetryModal);
            document.querySelectorAll('.help-btn').forEach((node) => {
                node.addEventListener('click', () => openDocsModal(node.dataset.doc || 'INDEX.md', node.dataset.docAnchor || null));
            });
            document.querySelectorAll('.kpi[data-overview]').forEach((node) => {
                node.addEventListener('click', (event) => {
                    if (event.target && event.target.closest('.help-btn')) return;
                    openOverviewModal(node.dataset.overview || 'agents');
                });
                node.addEventListener('keydown', (event) => {
                    if (event.target && event.target.closest('.help-btn')) return;
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        openOverviewModal(node.dataset.overview || 'agents');
                    }
                });
            });
            document.getElementById('docs-modal').addEventListener('click', (event) => {
                if (event.target && event.target.id === 'docs-modal') closeDocsModal();
            });
            document.getElementById('overview-modal').addEventListener('click', (event) => {
                if (event.target && event.target.id === 'overview-modal') closeOverviewModal();
            });
            document.getElementById('graph-fullscreen-modal').addEventListener('click', (event) => {
                if (event.target && event.target.id === 'graph-fullscreen-modal') closeGraphFullscreenModal();
            });
            document.getElementById('telemetry-modal').addEventListener('click', (event) => {
                if (event.target && event.target.id === 'telemetry-modal') closeTelemetryModal();
            });
            document.addEventListener('keydown', (event) => {
                if (event.key !== 'Escape') return;
                const graphModal = document.getElementById('graph-fullscreen-modal');
                if (graphModal && graphModal.classList.contains('open')) closeGraphFullscreenModal();
            });
            document.getElementById('investigation-breadcrumb').addEventListener('click', async (event) => {
                const node = event.target.closest('[data-bc-action]');
                if (!node) return;
                const action = node.getAttribute('data-bc-action') || '';
                const value = node.getAttribute('data-bc-value') || '';
                await handleBreadcrumbAction(action, value);
            });
            document.getElementById('investigation-breadcrumb').addEventListener('keydown', async (event) => {
                if (event.key !== 'Enter' && event.key !== ' ') return;
                const node = event.target.closest('[data-bc-action]');
                if (!node) return;
                event.preventDefault();
                const action = node.getAttribute('data-bc-action') || '';
                const value = node.getAttribute('data-bc-value') || '';
                await handleBreadcrumbAction(action, value);
            });
            await waitForReady(10, 450);
            const socket = io({ transports: ['websocket', 'polling'] });
            bindSocketHandlers(socket);
            await refreshInsights();
            setInterval(refreshInsights, 3500);
        })();
    </script>
</body>
</html>
